# **************************************************
# Copyright (c) 2017 Cisco Systems, Inc.
# All rights reserved.
# **************************************************

"""
Project - Bulldozer
ACL Ap Script
Authors:
1. Senthil Govindaraju
2. Nalinakshya Sahoo(nalsahoo)
3. Chaya N
4. Abhishek Jinde


"""

import pytest
from framework.pytest.cafy import Cafy
from framework.ap_base import ApBase
from topology.devices.device import Device
from topology.zap.zap import Zap
from logger.cafylog import CafyLog
from tgn.spirent import Spirent
from feature_lib.ifmgr import IfMgr
from feature_lib.acl import Acl
from feature_lib.aaa import Aaa
from feature_lib.icmp import IcmpXrCli
import hw.health_check
from tgn.spirent import *
from feature_lib.ip_static import IpStatic
from feature_lib.bundlemgr import BundleMgr
from hw.inventory import Inventory
from hw.process import Process
import os
from topology.topo_mgr.topo_mgr import Topology
from hw.triggers.cafy_event import CafyTriggers, CafyEventList, CafyEvent, CafyVerifier
from hw.event import Event
from feature_lib.l2vpn import L2Vpn
from feature_lib.ifmgr import IfMgr
from hw.inventory import Inventory
from feature_lib.gre import Gre
from feature_lib.qos import ClassMap
from feature_lib.qos import PolicyMap
from feature_lib.netflow import Netflow
from feature_lib.config import Config
from utils.cydiff.cydiff import CyDiff
import re
from hw.qos_hw import *
from acl_base_ap_compress import AclBaseAp

from pdb import set_trace
log = CafyLog(name="Acl AP")

#this file is changed again

class ApData:
    """
    Define all test level global data here. Only initialize.
    Donot call methods or access routers to initalize.
    All such methods should be moved to setup_* method
    """

    log = CafyLog(name="AclTest")

    prefix = os.path.dirname(os.path.abspath(__file__))

    topo_file = CafyLog.topology_file
    test_input_file = CafyLog.test_input_file

    if not test_input_file:
        test_input_file = os.path.join(prefix, "acl_ap_input.json")
    if not topo_file:
        topo_file = os.path.join(prefix, "acl_ap_topo.json")

    zap = Zap(test_input_file=test_input_file, topo_file=topo_file)

    mode = zap.get_base_configuration('mode')
    hw_module = zap.get_base_configuration('hw_module')
    bvi_support = zap.get_base_configuration('bvi_support')
    l2_support = zap.get_base_configuration('l2_support')

    UUT1 = zap.get_device('R1')
    PEER1 = zap.get_device('R2')
    UUT1_console = zap.get_device('R1')
    Tgen = zap.get_device('TGEN')
    acl_data = zap.get_feature_configuration('acl')
    acl_uut = Acl(device=UUT1, mode=mode, name="acl")
    acl_peer1= Acl(device=PEER1, mode=mode, name="acl")
    uut1_aaa = Aaa(device=UUT1, name='aaa', mode=mode)
    peer1_aaa = Aaa(device=PEER1, name='aaa', mode=mode)
    ifmgr = IfMgr(device=UUT1, mode=mode)
    uut1_icmp_obj = IcmpXrCli(device=UUT1, mode=mode)
    peer1_icmp_obj = IcmpXrCli(device=PEER1, mode=mode)
    uut1_health_chk_obj = hw.health_check.health_check_xr_cli.HealthCheckXrCli(device=UUT1, mode=mode)
    peer1_health_chk_obj = hw.health_check.health_check_xr_cli.HealthCheckXrCli(device=PEER1, mode=mode)
    inventory = Inventory(device=UUT1, mode=mode)
    UUT1_topo = Topology(topo_file=topo_file)
    UUT1_router = UUT1_topo.get_router(alias='R1')
    UUT1_platform = UUT1_router.platform.lower()
    PEER1_router = UUT1_topo.get_router(alias='R2')
    PEER1_platform = UUT1_router.platform.lower()
    # UUT1_linecard = UUT1_router.line_cards
    interface_linecard_details = dict()
    interface_loc = dict()
    devices = []

    for device_name in zap.devices:
        if re.match('tge?n', device_name, re.I):
            continue
        devices.append(zap.devices[device_name])

    uut1_ifmgr = IfMgr(device=UUT1, mode=mode)
    peer1_ifmgr = IfMgr(device=PEER1, mode=mode)
    uut1_l2vpn = L2Vpn(device=UUT1, mode=mode, name='l2vpn')
    peer1_l2vpn = L2Vpn(device=PEER1, mode=mode, name='l2vpn')
    interfaces = zap.get_interfaces(device=UUT1)
    interfaces_peer = zap.get_interfaces(device=PEER1)

        
        
    def verify_Bundle_TC(self,acl,sequance_no,TX_frame,addr_family, dir, location ,clear , verify):
        if clear == True:
           for lc in set(location):
               ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=addr_family,
                                       direction=dir,interface=None, location=lc)


def setup_module(module):
    ApData.log.info("Connecting to the devices")
    try:
        ApData.UUT1.connect(disable_logging_console=True)
        ApData.PEER1.connect(disable_logging_console=True)  
    except:
        ApData.log.info("Device connection refused")

    for device in ApData.devices:
        device.gre = Gre(device=device, name="gre", mode=ApData.mode)

    ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())

    ##########################################################################################

    with ApData.zap.get_topology().config(*ApData.devices, thread=True):
        ################### configuring interfaces ###############
        ApData.log.info("Interface configuration")
        for device in ApData.devices:
            if device.identifier != 'TGEN':
                interfaces = ApData.zap.get_interfaces(device=device)
                ifmgr = IfMgr(device=device, mode=ApData.mode)

                if ApData.bvi_support == True and ApData.l2_support == True:
                    ApData.zap.configure_interfaces(interfaces, ifmgr, device.gre)
                elif  ApData.bvi_support == False and ApData.l2_support == False:
                    device = device.identifier
                    value = 'tunnel-ip101.' + device
                    loop = 'Loopback0.' + device
                    if device == 'R1':
                        bvi = 'BVI7.' + device
                        del interfaces[bvi]
                    del interfaces[value]
                    del interfaces[loop]

                    # L2 config delete
                    for name, int_obj in interfaces.copy().items():
                        if hasattr(int_obj, 'vlans'):
                            for vlan, vlan_obj in int_obj.vlans.copy().items():
                                if hasattr(vlan_obj, 'l2'):
                                    del int_obj.vlans[vlan]

                    ApData.zap.configure_interfaces(interfaces, ifmgr)
                elif ApData.bvi_support == False:
                    device = device.identifier
                    value = 'tunnel-ip101.' + device
                    loop = 'Loopback0.' + device
                    if device == 'R1':
                        bvi = 'BVI7.' + device
                        del interfaces[bvi]
                    del interfaces[value]
                    del interfaces[loop]
                    ApData.zap.configure_interfaces(interfaces, ifmgr)
                elif ApData.l2_support == False:
                    for name, int_obj in interfaces.copy().items():
                        if hasattr(int_obj, 'vlans'):
                            for vlan, vlan_obj in int_obj.vlans.copy().items():
                                if hasattr(vlan_obj, 'l2'):
                                    del int_obj.vlans[vlan]
                    ApData.zap.configure_interfaces(interfaces, ifmgr, device.gre)

    with ApData.zap.get_topology().config(*ApData.devices, thread=True):
        ApData.log.info("Configuring Static Route")
    ##################### static routes #######################
        ipstatic_config_data = ApData.zap.get_feature_configuration("ipstatic/R1")
        ipstatic_obj = IpStatic(device=ApData.UUT1, name='ipstatic', mode=ApData.mode)
        for afi in ipstatic_config_data:
            paths = []
            for i, elem in enumerate(ipstatic_config_data[afi]["static_prefixes"]):
                paths.append({'prefix': elem,
                              'prefix_length': ipstatic_config_data[afi]["prefix_length"],
                              'next_hop': ipstatic_config_data[afi]["next_hops"][i],
                              })

            ipstatic_obj.config_static_route(address_family=afi, paths=paths)

        ipstatic_config_data = ApData.zap.get_feature_configuration("ipstatic/R2")
        ipstatic_obj = IpStatic(device=ApData.PEER1, name='ipstatic', mode=ApData.mode)
        for afi in ipstatic_config_data:
            paths = []
            for i, elem in enumerate(ipstatic_config_data[afi]["static_prefixes"]):
                paths.append({'prefix': elem,
                              'prefix_length': ipstatic_config_data[afi]["prefix_length"],
                              'next_hop': ipstatic_config_data[afi]["next_hops"][i],
                              })

            ipstatic_obj.config_static_route(address_family=afi, paths=paths)
        
        #################################################################################
        ipstatic_config_data = ApData.zap.get_feature_configuration("ipstatic_16/R1")
        ipstatic_obj = IpStatic(device=ApData.UUT1, name='ipstatic1', mode=ApData.mode)
        for afi in ipstatic_config_data:
            paths = []
            for i, elem in enumerate(ipstatic_config_data[afi]["static_prefixes"]):
                paths.append({'prefix': elem,
                              'prefix_length': ipstatic_config_data[afi]["prefix_length"],
                              'next_hop': ipstatic_config_data[afi]["next_hops"][i],
                              })

            ipstatic_obj.config_static_route(address_family=afi, paths=paths)

        ipstatic_config_data = ApData.zap.get_feature_configuration("ipstatic_16/R2")
        ipstatic_obj = IpStatic(device=ApData.PEER1, name='ipstatic1', mode=ApData.mode)
        for afi in ipstatic_config_data:
            paths = []
            for i, elem in enumerate(ipstatic_config_data[afi]["static_prefixes"]):
                paths.append({'prefix': elem,
                              'prefix_length': ipstatic_config_data[afi]["prefix_length"],
                              'next_hop': ipstatic_config_data[afi]["next_hops"][i],
                              })

            ipstatic_obj.config_static_route(address_family=afi, paths=paths)
    
    ################################################################################
    ################################################################################
    if ApData.bvi_support == True:
        ApData.log.info("Configuring the BVI Interface")
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.uut1_ifmgr.set_rewrite_ingress_tag_pop(ApData.intf, 1, symmetric=True)
        ApData.uut1_l2vpn.set_bridge_group(port_list=[ApData.intf], bridge_group_name="7", bridge_domain_name="7",
                                           bvi_interface="BVI7")
        ApData.xconnect = ApData.acl_data['test_args']['xconnect_group']
        xc_group_name = ApData.xconnect['xconnect_group_name']
        xc_name = ApData.xconnect['xc_name']
        xc_type = ApData.xconnect['type']

        segment = ApData.xconnect['xc_group']['segment']

        for i in range(1, len(segment) + 1):
            link_name = segment[str(i)]['intf']
            interface_name = ApData.interfaces_peer[link_name].name
            segment[str(i)]['intf'] = interface_name
        xc_dict = {}
        xc_dict['segment'] = segment
        ApData.peer1_l2vpn.set_xconnect_v2(xc_group_name, xc_name, xc_type, xc_dict)

##################################################################################################

    if ApData.l2_support == True:
        with ApData.zap.get_topology().config(*ApData.devices, thread=True):
            ApData.log.info("Configuring the L2 interface")
        
            ApData.xconnect = ApData.acl_data['test_args']['bridge_group_uut']
            xc_group_name = ApData.xconnect['xconnect_group_name']
            xc_name = ApData.xconnect['xc_name']
            xc_type = ApData.xconnect['type']
            segment = ApData.xconnect['xc_group']['segment']
        
            for i in range(1, len(segment) + 1):
                link_name = segment[str(i)]['intf']
                interface_name = ApData.interfaces[link_name].name
                segment[str(i)]['intf'] = interface_name
            xc_dict={}
            xc_dict['segment']=segment
            ApData.uut1_l2vpn.set_xconnect_v2(xc_group_name, xc_name, xc_type, xc_dict)
        
            ##########################
            ApData.xconnect = ApData.acl_data['test_args']['bridge_group_peer']
            xc_group_name = ApData.xconnect['xconnect_group_name']
            xc_name = ApData.xconnect['xc_name']
            xc_type = ApData.xconnect['type']
            segment = ApData.xconnect['xc_group']['segment']
         
            for i in range(1, len(segment) + 1):
                link_name = segment[str(i)]['intf']
                interface_name = ApData.interfaces_peer[link_name].name
                segment[str(i)]['intf'] = interface_name
            xc_dict={}
            xc_dict['segment']=segment
            ApData.peer1_l2vpn.set_xconnect_v2(xc_group_name, xc_name, xc_type, xc_dict)
    ########################################################################################
    ApData.bundle_members_location=list()
    intfl=ApData.interfaces['Bundle-Ether500.R1'].members
    ApData.bundle_members_location.append(ApData.zap.get_node_name(device_objs=ApData.acl_uut, interface=intfl[0].interface))
    ApData.bundle_members_location.append(ApData.zap.get_node_name(device_objs=ApData.acl_uut, interface=intfl[1].interface))

    if ApData.hw_module == True:
        ApData.acl_uut.set_hw_module_profile_stats_acl_permit()
        ApData.acl_uut.set_hw_module_profile_ttl_match()
        ApData.acl_uut.set_hw_module_profile_ttl_match(address_family='ipv6')
        #ApData.acl_uut.set_hardware_profile_common_acl(address_family="ipv6")
        AclBaseAp._set_VmReload(ApData)
        ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())

    ###############################################################################################

    ApData.log.info("Connecting to the TGEN, loading the XML file and starting the traffic")
    if ApData.Tgen.platform == 'IXIA':
        try:
            ixia_port_list = list(ApData.Tgen.interfaces.keys())
            ixia_config_file = ApData.zap.get_base_configuration("ixia_config")
            ApData.Tgen.load_config(ixia_config_file, port_tuple=ixia_port_list)
        except:
            pytest.log('IXIA is not supported Exiting....')
    else:
        # stc_server = ApData.zap.get_base_configuration("stc_server")
        stc_server = ApData.Tgen.server_ip
                                
        ApData.Tgen.intfs = ApData.zap.get_interfaces(device=ApData.Tgen)
        list_1 = []
        link = ApData.zap.get_link("R1_T1_1")
        ApData.TGN_R1_intf1 = ApData.Tgen.get_local(link).name
        list_1.append(ApData.TGN_R1_intf1)
        link = ApData.zap.get_link("R2_T1_1")
        ApData.TGN_R2_intf1 = ApData.Tgen.get_local(link).name
        list_1.append(ApData.TGN_R2_intf1)
        link = ApData.zap.get_link("R1_T1_2")
        ApData.TGN_R1_intf2 = ApData.Tgen.get_local(link).name
        list_1.append(ApData.TGN_R1_intf2)

        link = ApData.zap.get_link("R2_T1_2")
        ApData.TGN_R2_intf2 = ApData.Tgen.get_local(link).name
        list_1.append(ApData.TGN_R2_intf2)
        spirent_port_list_tuple = list_1

        prefix = os.path.dirname(os.path.abspath(__file__))
        config_file = os.path.join(prefix, "spirent.xml")
        spirent_connection = ApData.Tgen.load_config(config_file=config_file, port_tuple=spirent_port_list_tuple)
        
        #spirent_connection = ApData.zap.load_tgn_config_file(device=ApData.Tgen, config_path='base_config',
                                                                 #ports=spirent_port_list_tuple)

        if not spirent_connection:
            raise CafyException.VerificationError('Errored while connecting to Spirent')
        else:
            ApData.stream_handle = ApData.Tgen._get_dict_traffic_streams()

    Helper.sleep(20, msg='Waiting for 20 seconds after configuring the interface')

    
    ApData.stream_handle = ApData.Tgen.get_all_traffic_streams()
    ApData.log.info(ApData.stream_handle)

    ApData.stream_name = ApData.Tgen.get_traffic_items()
    ApData.log.info(ApData.stream_name)
    
    
    ApData.Tgen.start_arp()
    Helper.sleep(30, msg='ARP request sent')
    if not ApData.Tgen.verify_arp_status():
        ApData.log.info("ARP status verification has failed")

    ApData.Tgen.start_traffic()
    Helper.sleep(10, msg='Let the traffic to run for 10 seconds')

    ApData.Tgen.stop_traffic()

    ApData.log.info("Clearing counters in spirent")
    ApData.Tgen._perform('ResultClearAllTrafficCommand')
    ApData.Tgen.start_traffic()
    Helper.sleep(20, msg='Let the traffic to run for 30 seconds')

    ApData.Tgen.stop_traffic()
    traffic_stats = {}
    try:
        traffic_stats = ApData.Tgen.verify_traffic(tolerance=5)

        ApData.log.info(traffic_stats)
    except Exception as e:
        traffic_stats = e
        traffic_stats = traffic_stats.args[0]

    item_stats = traffic_stats[0]
    flow_stats = traffic_stats[1]
    ApData.stream_stats = {}

    for i in range(1, len(item_stats) + 1):
        stream_name = item_stats[i]['Traffic Item']
        ApData.stream_stats[stream_name] = item_stats[i]
        ApData.log.info(ApData.stream_stats[stream_name])

    ApData.log.info("Stream name : ", ApData.stream_stats)

    for stream in ApData.stream_stats:
        txcount = ApData.stream_stats[stream]['Tx Frames']
        rxcount = ApData.stream_stats[stream]['Rx Frames']
        ApData.log.info("ApData.stream_stats[stream]")
        ApData.log.info(rxcount)
        ApData.log.info(txcount)

    ApData.log.info("Configuring ACL")
    ApData.topo = ApData.zap.get_topology()
    with ApData.topo.config(ApData.UUT1, thread=True):
        ApData.zap.set_aclace(ApData.acl_data, ApData.acl_uut)
    Helper.sleep(90, msg='waiting for configuration to take place')


def teardown_module(module):
    """
    Module level cleanup.
    It is run once per test package at the end of test. Ideally this should even restore the device
    to the state where it was begin. Best practices are
    - Collect cores (Use APIs)
    - Memory profile of router
    - Rollback configuration.
    """
    ApData.acl_data = ApData.zap.get_feature_configuration('acl')
    ApData.topo = ApData.zap.get_topology()

    with ApData.topo.config(ApData.UUT1, thread=True):
        ApData.zap.remove_acl(ApData.acl_data, ApData.acl_uut)

    log.info("Disconnecting TGN")
    ApData.Tgen.tgn_disconnect()
    ApData.Tgen._end_session()
    ApData.log.info("Module Teardown")
    ApData.UUT1.disconnect()
    ApData.PEER1.disconnect()



#####************************************************************************************
@pytest.mark.Feature('ObjectGroups')
class TestIPv4PortIngressAclLesserThan(AclBaseAp):

    def setup_class(self):
        """
        Create IPv6 port object group and create ACL
        
        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='lt',
            port_number=1025,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortIngressAclLesserThan(self):
        """
        IPV4 Port Object-Group parameter Port number and LessThan option type set on Ingress Phy intf
        
        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Lesser Than specified port number

        Test Procedure:
            - Config Port Object group with LesserThan 1025 port number 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic 
            - Verify packet with LesserThan port no 1025 hit ACE  
        
        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to Phy sub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_PhySub']['Tx Frames'])

        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='lt',
            port_number=1025,
            mode="unconfig")
    #####************************************************************************************

@pytest.mark.Feature('ObjectGroups')
class TestIPv4PortIngressAclEqualto(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 port object group and create ACL
        
        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='eq',
            port_number=1024,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortIngressAclEqualto(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf
        
        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic 
            - Verify packet with Equal to port no 1024 hit ACE  

        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to Phy interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")
    #####************************************************************************************

@pytest.mark.Feature('ObjectGroups')
class TestIPv4PortIngressAclNotEqual(AclBaseAp):
    """
    Create IPv6 port object group and create ACL
    
    Apply acl to an ingress interface and verify the tx and rx from traffic stream.
    :return: None
    """

    def setup_class(self):
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='neq',
            port_number=1023,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv4_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortIngressAclNotEqual(self):
        """
        IPV4 Port Object-Group parameter Port number and Not Equal to option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Not Equale to specified port number

        Test Procedure:
            - Config Port Object group with Not Equal 1023 port number 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic 
            - Verify packet with Not Equal to port no 1023 hit ACE  
        
        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to Phy interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")


        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='neq',
            port_number=1023,
            mode="unconfig")

@pytest.mark.irfb
class TestIPv4PortIngressBackupAclEqualtoPhysicalCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_tcp_physical_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortIngressAclEqualtoCompress(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkPortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        pdb.set_trace()
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")
    #####************************************************************************************



########################## CompressACL Starts########################################
@pytest.mark.irfPhysical
class TestIPv4PortIngressAclEqualtoPhysicalCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="config")
        for network in ['30.0.20.0/24','30.0.10.0/24','120.1.1.0/24','120.1.2.0/24','130.1.1.0/24','130.1.2.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_host',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_tcp_physical_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortIngressAclEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkPortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def test_verify_IPv4PortIngressAclEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkPortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")

        for network in ['30.0.20.0/24','30.0.10.0/24','120.1.1.0/24','120.1.2.0/24','130.1.1.0/24','130.1.2.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_host',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

    #####************************************************************************************

@pytest.mark.irfPhysical
class TestIPv4PortEgressAclEqualtoPhysicalCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="config")
        for network in ['30.0.20.0/24','30.0.10.0/24','120.1.1.0/24','120.1.2.0/24','130.1.1.0/24','130.1.2.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_host',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_tcp_physical_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortEgressAclEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkPortObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def test_verify_IPv4PortEgressAclEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkPortObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")
        for network in ['30.0.20.0/24','30.0.10.0/24','120.1.1.0/24','120.1.2.0/24','130.1.1.0/24','130.1.2.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_host',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")
    #####************************************************************************************


@pytest.mark.irfBundle
class TestIPv4PortEgressAclEqualtoBundleCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfanBunl port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['140.1.2.1', '150.1.2.1', '120.1.1.1', '120.1.2.1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_tcp_bundle_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortEgressAclEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4NetworkPortObjectGroupEgressAclBun']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        #loc.append(ApData.hw_loc)
        loc.append(ApData.hw_loc)

        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)
        import pdb
        # pdb.set_trace()
        stream = ['uut2_TCP_Bundle', 'uut2_UDP_Bundle','uut2_OSPF_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_bundle_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut2_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut2_UDP_Bundle']['Tx Frames'])
        ospf_count = int(ApData.stream_stats['uut2_OSPF_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(ospf_count, extra=False),
                                                                AclBaseAp.tolerance_value(ospf_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_UDP_Bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_OSPF_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[2]['sequence_number']: [ospf_count, rx_count3]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def test_verify_IPv4PortEgressAclEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4NetworkPortObjectGroupEgressAclBun']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)
        import pdb
        # pdb.set_trace()
        stream = ['uut2_TCP_Bundle', 'uut2_UDP_Bundle', 'uut2_OSPF_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_bundle_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut2_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut2_UDP_Bundle']['Tx Frames'])
        ospf_count = int(ApData.stream_stats['uut2_OSPF_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(ospf_count, extra=False),
                                                                AclBaseAp.tolerance_value(ospf_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_UDP_Bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_OSPF_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[2]['sequence_number']: [ospf_count, rx_count3]},

                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='eq',
            port_number=1023,
            mode="unconfig")

        for network in ['140.1.2.1', '150.1.2.1', '120.1.1.1', '120.1.2.1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="unconfig")
    #####************************************************************************************

@pytest.mark.irfBundle
class TestIPv4PortIngressAclEqualtoBundleCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfanBunl port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['140.1.2.1', '150.1.2.1', '120.1.1.1', '120.1.2.1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_tcp_bundle_ingress_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv4PortIngressAclEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        #import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4NetworkPortObjectGroupIngressAclBun']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)
        #AclBaseAp._get_loc_interfaces(ApData, ApData.intf)


        import pdb
        # pdb.set_trace()
        stream = ['peer2_In_TCP_Bundle', 'peer2_In_UDP_Bundle','peer2_In_OSPF_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_bundle_ingress_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer2_In_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer2_In_UDP_Bundle']['Tx Frames'])
        ospf_count = int(ApData.stream_stats['peer2_In_OSPF_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(ospf_count, extra=False),
                                                                AclBaseAp.tolerance_value(ospf_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer2_In_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer2_In_UDP_Bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['peer2_In_OSPF_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[2]['sequence_number']: [ospf_count, rx_count3]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def test_verify_IPv4PortIngressAclEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4NetworkPortObjectGroupIngressAclBun']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)
        import pdb
        # pdb.set_trace()
        stream = ['peer2_In_TCP_Bundle', 'peer2_In_UDP_Bundle', 'peer2_In_OSPF_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_tcp_bundle_ingress_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer2_In_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer2_In_UDP_Bundle']['Tx Frames'])
        ospf_count = int(ApData.stream_stats['peer2_In_OSPF_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(ospf_count, extra=False),
                                                                AclBaseAp.tolerance_value(ospf_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer2_In_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer2_In_UDP_Bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['peer2_In_OSPF_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[1]['sequence_number']: [ospf_count, rx_count3]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")

        for network in ['140.1.2.1', '150.1.2.1', '120.1.1.1', '120.1.2.1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="unconfig")
    #####************************************************************************************

@pytest.mark.irfBundle
class TestIPv6PortIngressAclEqualtoBundleCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfanBunl port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['150:1:2::1', '140:1:2::1', '160:1:2::1', '160:1:2::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_tcp_bundle_ingress_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6PortIngressAclEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None V6NetworkPortObjectGroupIngressAclBundle

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupIngressAclBundle']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=lc)
        import pdb
        pdb.set_trace()
        stream = ['peer2_In_IPV6_TCP_Bundle', 'peer2_In_IPV6_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_tcp_bundle_ingress_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer2_In_IPV6_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer2_In_IPV6_UDP_Bundle']['Tx Frames'])

        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),AclBaseAp.tolerance_value(udp_count, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer2_In_IPV6_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer2_In_IPV6_UDP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],seq[1]['sequence_number']: [udp_count, rx_count2]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def test_verify_IPv6PortIngressAclEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupIngressAclBundle']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)
        import pdb
        # pdb.set_trace()
        stream = ['peer2_In_IPV6_TCP_Bundle', 'peer2_In_IPV6_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_tcp_bundle_ingress_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer2_In_IPV6_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer2_In_IPV6_UDP_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer2_In_IPV6_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer2_In_IPV6_UDP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")

        for network in ['150:1:2::1', '140:1:2::1', '160:1:2::1', '160:1:2::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")
    #####************************************************************************************

@pytest.mark.irfBundle
class TestIPv6PortEgressAclEqualtoBundleCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfanBunl port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['150:1:2::1', '140:1:2::1', '160:1:2::1', '160:1:2::1','150:1:2::1','140:1:2::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        import pdb
        pdb.set_trace()
        aclname = "ipv6_ob_network_port_tcp_bundle_egress_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6PortEgressAclEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupEgressAclBundle']
        #AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=lc)
        import pdb
        # pdb.set_trace()
        stream = ['uut2_IPV6_TCP_Bundle', 'uut2_IPV6_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_tcp_bundle_egress_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Tx Frames'])

        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[0]['sequence_number'],matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False), AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def test_verify_IPv6PortEgressAclEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupEgressAclBundle']
        # AclBaseAp._get_tcs_data(ApData)
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        # AclBaseAp._get_loc_int(ApData, ApData.intf)
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)
        import pdb
        # pdb.set_trace()
        stream = ['uut2_IPV6_TCP_Bundle', 'uut2_IPV6_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_tcp_bundle_egress_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['150:1:2::1', '140:1:2::1', '160:1:2::1', '160:1:2::1', '150:1:2::1', '140:1:2::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_object_group_bundle_host',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="unconfig")
    #####************************************************************************************


@pytest.mark.irfPhysical
class TestIPv6NetworkAclGroupIngressPhysicalCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="config")
        for network in ['120:1::/64','130:1::/64']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_physical_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkAclGrouoEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        pdb.set_trace()
        stream = ['uu1_IPV6_main', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uu1_IPV6_main']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uu1_IPV6_main']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def test_verify_IPv6NetworkAclGrouoEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupEgressAclPhyCompress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uu1_IPV6_main', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uu1_IPV6_main']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uu1_IPV6_main']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")
        for network in ['120:1::/64','120:1:1::/64','130:1::/64','130:1:1::/96']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

@pytest.mark.irfPhysical
class TestIPv6NetworkAclGroupEgressPhysicalCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="config")
        for network in ['120:1::/64','130:1::/64']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_physical_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkAclGrouoEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uu1_IPV6_main', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uu1_IPV6_main']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])
        import pdb
        pdb.set_trace()

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uu1_IPV6_main']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def test_verify_IPv6NetworkAclGrouoEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uu1_IPV6_main', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_physical_main"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uu1_IPV6_main']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uu1_IPV6_main']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")
        for network in ['120:1::/64','120:1:1::/64','130:1::/64','130:1:1::/96']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

@pytest.mark.irfPhysical
class TestIpv4AclPhySubIngressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['130.1.1.0/24','120.1.1.0/24','120.1.3.0/24','137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_physical_sub"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def testipv4tcp_per_physub_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        import pdb
        pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_physical_sub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']


        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub','uut1_GRE_physub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_physical_sub"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub','uut1_GRE_physub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        #matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDP_PhySub']['Tx Frames'])
        gre_count = int(ApData.stream_stats['uut1_GRE_physub']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(gre_count, extra=False),
                                                                AclBaseAp.tolerance_value(gre_count, extra=True))))

        rx_count1 = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_PhySub']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_GRE_physub']['Rx Frames']

        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[2]['sequence_number']: [udp_count, rx_count3]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        #ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc5']
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_physical_sub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['130.1.1.0/24', '120.1.1.0/24', '120.1.3.0/24', '137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

@pytest.mark.irfPhysical
class TestIpv4AclPhySubEgressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['130.1.1.0/24','120.1.1.0/24','120.1.3.0/24','137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_physical_sub"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def testipv4tcp_per_physub_engress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        import pdb
        pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_physical_sub_egress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']


        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub','uut1_GRE_physub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_ob_network_port_physical_sub"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub','uut1_GRE_physub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        #matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDP_PhySub']['Tx Frames'])
        gre_count = int(ApData.stream_stats['uut1_GRE_physub']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(gre_count, extra=False),
                                                                AclBaseAp.tolerance_value(gre_count, extra=True))))

        rx_count1 = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_PhySub']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_GRE_physub']['Rx Frames']

        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[2]['sequence_number']: [udp_count, rx_count3]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        #ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc5']
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_physical_sub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['130.1.1.0/24', '120.1.1.0/24', '120.1.3.0/24', '137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

@pytest.mark.irfPhysical
class TestIpv6AclPhySubEgressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_physical_sub"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def testipv6tcp_per_physub_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_physical_sub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=ApData.intf, mode="config")

        # stream = ['uut1_IPV6_UDP_PhySub', 'uut1_IPV6_UDP_PhySub']
        # AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_ob_network_port_physical_sub"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_IPV6_TCP_Physub', 'uut1_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        #matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Physub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      },
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        #ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc5']
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_physical_sub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")

@pytest.mark.irfPhysical
class TestIpv6AclPhySubIngressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_physical_sub_ingress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def testipv6tcp_per_physub_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_physical_sub_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        aclname1 = "ipv6_ob_network_port_physical_sub_ingress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=ApData.intf, mode="config")

        # stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub', ]
        # AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_IPV6_TCP_Physub', 'uut1_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        #matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Physub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      },
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        #ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc5']
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_physical_sub_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")

@pytest.mark.irfBundle
class TestIpv4AclBundleSubIngressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['130.1.3.0/24','120.1.3.0/24','120.1.3.0/24','137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_bundle_sub"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_ipv4_tcp_per_bundle_sub_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None ob_network_port_bundle_sub_inress

        "tc7": {
        							"aclname": "ipv4_permit_tcp_any_any",
        							"address_family": "ipv4",
        							"intf_list": "Bundle-Ether500.R1",
        							"direction": "ingress",
        							"subint": "3"
        						},
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_bundle_sub_inress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        aclname1 = "ipv4_ob_network_port_bundle_sub"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['peer1_In_TCP_BunSub','peer1_In_UDP_BunSub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tcp_count = ApData.stream_stats['peer1_In_TCP_BunSub']['Tx Frames']
        udp_count = ApData.stream_stats['peer1_In_UDP_BunSub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[0]['sequence_number'],
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                               AclBaseAp.tolerance_value(tcp_count, extra=True))))

        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[1]['sequence_number'],
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(udp_count, extra=False),
                                                               AclBaseAp.tolerance_value(udp_count, extra=True))))
        rx_count1 = ApData.stream_stats['peer1_In_TCP_BunSub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_BunSub']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_bundle_sub_inress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['130.1.3.0/24', '120.1.3.0/24', '120.1.3.0/24', '137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

@pytest.mark.irfBundle
class TestIpv4AclBundleSubEgressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['130.1.3.0/24','120.1.3.0/24','120.1.3.0/24','137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv4_ob_network_port_bundle_sub_egress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_ipv4_tcp_per_bundle_sub_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None ob_network_port_bundle_sub_inress

        "tc7": {
        							"aclname": "ipv4_permit_tcp_any_any",
        							"address_family": "ipv4",
        							"intf_list": "Bundle-Ether500.R1",
        							"direction": "ingress",
        							"subint": "3"
        						},
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_bundle_sub_egress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        aclname1 = "ipv4_ob_network_port_bundle_sub_egress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['uut1_TCP_bunsub','uut1_UDP_bunsub','uut1_GRE_BunSub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        loc.append(ApData.hw_loc)

        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)
        import pdb
        pdb.set_trace()
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tcp_count = ApData.stream_stats['uut1_TCP_bunsub']['Tx Frames']
        udp_count = ApData.stream_stats['uut1_UDP_bunsub']['Tx Frames']
        gre_count = ApData.stream_stats['uut1_GRE_BunSub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[0]['sequence_number'],
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                               AclBaseAp.tolerance_value(tcp_count, extra=True))))

        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[1]['sequence_number'],
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(udp_count, extra=False),
                                                               AclBaseAp.tolerance_value(udp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(gre_count, extra=False),
                                               AclBaseAp.tolerance_value(gre_count, extra=True))))
        rx_count1 = ApData.stream_stats['uut1_TCP_bunsub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_bunsub']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_GRE_BunSub']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2],
                                                      seq[2]['sequence_number']: [udp_count, rx_count3]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_bundle_sub_egress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['130.1.3.0/24', '120.1.3.0/24', '120.1.3.0/24', '137.0.0.0/24']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='network_V4_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="unconfig")

@pytest.mark.irfBundle
class TestIpv6AclBundleSubEgressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['130:1:3::1','120:1:3::1','140:1:3::1','150:1:3::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_bundle_sub_egress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_ipv6_tcp_per_bundle_sub_engress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None ob_network_port_bundle_sub_inress

        "tc7": {
        							"aclname": "ipv4_permit_tcp_any_any",
        							"address_family": "ipv4",
        							"intf_list": "Bundle-Ether500.R1",
        							"direction": "ingress",
        							"subint": "3"
        						},
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_bundle_sub_egress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        aclname1 = "ipv6_ob_network_port_bundle_sub_egress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")


        stream = ['uut1_IPV6_TCP_BunSub','uut1_IPV6_UDP_BunSub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        import pdb
        pdb.set_trace()
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=lc)


        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tcp_count = ApData.stream_stats['uut1_IPV6_TCP_BunSub']['Tx Frames']
        udp_count = ApData.stream_stats['uut1_IPV6_UDP_BunSub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[0]['sequence_number'],
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                               AclBaseAp.tolerance_value(tcp_count, extra=True))))

        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[1]['sequence_number'],
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(udp_count, extra=False),
                                                               AclBaseAp.tolerance_value(udp_count, extra=True))))


        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_BunSub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_BunSub']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_bundle_sub_egress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['130:1:3::1', '120:1:3::1', '140:1:3::1', '150:1:3::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="unconfig")


@pytest.mark.irfBundle
class TestIpv6AclBundleSubIngressCompress(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1023',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['130:1:3::1', '120:1:3::1', '140:1:3::1', '150:1:3::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_bundle_sub_ingress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_ipv4_tcp_per_bundle_sub_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None ob_network_port_bundle_sub_inress

        "tc7": {
        							"aclname": "ipv4_permit_tcp_any_any",
        							"address_family": "ipv4",
        							"intf_list": "Bundle-Ether500.R1",
        							"direction": "ingress",
        							"subint": "3"
        						},
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_bundle_sub_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        aclname1 = "ipv6_ob_network_port_bundle_sub_ingress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="config")
        stream = ['peer1_In_IPV6_TCP_BunSub', 'peer1_In_IPV6_UDP_BunSub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        #loc.append(ApData.hw_loc)
        loc.append(ApData.hw_loc)

        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=lc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tcp_count = ApData.stream_stats['peer1_In_IPV6_TCP_BunSub']['Tx Frames']
        udp_count = ApData.stream_stats['peer1_In_IPV6_UDP_BunSub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(tcp_count, extra=False),
                                               AclBaseAp.tolerance_value(tcp_count, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(udp_count, extra=False),
                                               AclBaseAp.tolerance_value(udp_count, extra=True))))

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_BunSub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_BunSub']['Rx Frames']

        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['ob_network_port_V6_bundle_sub_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="unconfig")

        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_gt_1024',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")
        for network in ['130:1:3::1', '120:1:3::1', '140:1:3::1', '150:1:3::1']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=None,
                host=network,
                range=None,
                object_group=None,
                mode="unconfig")


@pytest.mark.irfPhysical
class TestIPv4AclPhysicalBundleCompress(AclBaseAp):

    def test_verify_IPv4_same_acl_on_Physical_Bundle_CompressLevel1(self):
        """

        This testcase Verify same ACL on both Physical and Bundle configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config ACL
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress  and Bundle Egress direction
            - Send traffic
            - Verify packet

        Configurations:
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=ApData.intf, mode="config")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundleBundle']

        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        bundle_intf = ApData.intf
        bundle_dir = ApData.dir
        bundle_add_family = ApData.addr_family
        bundle__loc = loc
        bundle_aclname = ApData.aclname
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=None, location=lc)
        stream = ['uut2_v4_tcp_dscp_ttl_pl_bundle','uut2_v4_udp_dscp_ttl_pl_bundle','uut2_OSPF_Bundle','uut2_ICMP_Bundle',
                  'uu1_v4_TCP_dscp_ttl','uu1_v4_UDP_dscp_ttl','uut1_ICMPstream1','uut1_ICMP_echoreply']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        import pdb
        #pdb.set_trace()

        seq = ApData.acl_data['aclnames'][ApData.aclname]

        verifier_obj = []
        tcp_count_bundle = int(ApData.stream_stats['uut2_v4_tcp_dscp_ttl_pl_bundle']['Tx Frames'])
        udp_count_bundle = int(ApData.stream_stats['uut2_v4_udp_dscp_ttl_pl_bundle']['Tx Frames'])
        ospf_count_bundle = int(ApData.stream_stats['uut2_OSPF_Bundle']['Tx Frames'])
        icmp_count_bundle = int(ApData.stream_stats['uut2_ICMP_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count_bundle, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count_bundle, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(ospf_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(ospf_count_bundle, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[3]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp_count_bundle, extra=False),
                                               AclBaseAp.tolerance_value(icmp_count_bundle, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_v4_tcp_dscp_ttl_pl_bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_v4_udp_dscp_ttl_pl_bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_OSPF_Bundle']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut2_ICMP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count_bundle, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count_bundle, rx_count2],
                                                      seq[2]['sequence_number']: [ospf_count_bundle, rx_count3],
                                                      seq[3]['sequence_number']: [icmp_count_bundle, rx_count4]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundlePhysical']

        AclBaseAp._get_tcs_data(ApData)


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        physical_intf = ApData.intf
        physical_dir = ApData.dir
        physical_add_family = ApData.addr_family
        AclBaseAp._get_loc_int(ApData, physical_intf)
        physical_loc = ApData.hw_loc
        physical_aclname = ApData.aclname

        # ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
        #                                direction=ApData.dir,
        #                                interface=None, location=ApData.hw_loc)


        seq = ApData.acl_data['aclnames'][ApData.aclname]
        verifier_obj = []
        tcp_count_physical = int(ApData.stream_stats['uu1_v4_TCP_dscp_ttl']['Tx Frames'])
        udp_count_physical = int(ApData.stream_stats['uu1_v4_UDP_dscp_ttl']['Tx Frames'])
        icmp1_count_physical = int(ApData.stream_stats['uut1_ICMPstream1']['Tx Frames'])
        icmp_count_physical = int(ApData.stream_stats['uut1_ICMP_echoreply']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[4]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[5]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[6]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[7]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp_count_physical, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uu1_v4_TCP_dscp_ttl']['Rx Frames']
        rx_count2 = ApData.stream_stats['uu1_v4_UDP_dscp_ttl']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_ICMPstream1']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut1_ICMP_echoreply']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[4]['sequence_number']: [tcp_count_physical, rx_count1],
                                                      seq[5]['sequence_number']: [udp_count_physical, rx_count2],
                                                      seq[6]['sequence_number']: [icmp1_count_physical, rx_count3],
                                                      seq[7]['sequence_number']: [icmp_count_physical, rx_count4]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.log.info("Un Configuring acl from Bundle interface")

        ApData.acl_uut.set_acl_to_interface(access_list_name=bundle_aclname, address_family=bundle_add_family,
                                            direction=bundle_dir,
                                            interface=bundle_intf, mode="unconfig")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundleBundle']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.irfPhysical
class TestIPv6AclPhysicalBundleCompress(AclBaseAp):

    def test_verify_IPv6_same_acl_on_Physical_Bundle_CompressLevel1(self):
        """

        This testcase Verify same ACL on both Physical and Bundle configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config ACL
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress  and Bundle Egress direction
            - Send traffic
            - Verify packet

        Configurations:
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=ApData.intf, mode="config")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundleBundle']

        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        bundle_intf = ApData.intf
        bundle_dir = ApData.dir
        bundle_add_family = ApData.addr_family
        bundle__loc = loc
        bundle_aclname = ApData.aclname
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=None, location=lc)
        #stream = ['uut2_v4_tcp_dscp_ttl_pl_bundle','uut2_v4_udp_dscp_ttl_pl_bundle','uut2_OSPF_Bundle','uut2_ICMP_Bundle','uu1_v4_TCP_dscp_ttl','uu1_v4_UDP_dscp_ttl','uut1_ICMPstream1','uut1_ICMP_echoreply']
        stream = ['uut2_IPV6_TCP_Bundle','uut2_IPV6_UDP_Bundle','uut2_V6_pim_dscp_bundle',
                  'uut1_IPV6_TCP_Phy','uut1_IPV6_UDP_Phy','uut1_IPV6_ICMP_time_exceed',
                  'uut1_IPV6_ICMP_echoreply','uut1_IPV6_ICMP_dest_unreach']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        seq = ApData.acl_data['aclnames'][ApData.aclname]
        import pdb
        #pdb.set_trace()

        verifier_obj = []
        tcp_count_bundle = int(ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Tx Frames'])
        udp_count_bundle = int(ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Tx Frames'])
        pim_count_bundle = int(ApData.stream_stats['uut2_V6_pim_dscp_bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count_bundle, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count_bundle, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(pim_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(pim_count_bundle, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_V6_pim_dscp_bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count_bundle, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count_bundle, rx_count2],
                                                      seq[2]['sequence_number']: [pim_count_bundle, rx_count3],
                                                      },
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundlePhysical']

        AclBaseAp._get_tcs_data(ApData)


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        physical_intf = ApData.intf
        physical_dir = ApData.dir
        physical_add_family = ApData.addr_family
        AclBaseAp._get_loc_int(ApData, physical_intf)
        physical_loc = ApData.hw_loc
        physical_aclname = ApData.aclname

        # ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
        #                                direction=ApData.dir,
        #                                interface=None, location=ApData.hw_loc)


        seq = ApData.acl_data['aclnames'][ApData.aclname]
        verifier_obj = []
        tcp_count_physical = int(ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames'])
        udp_count_physical = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])
        icmp1_count_physical = int(ApData.stream_stats['uut1_IPV6_ICMP_time_exceed']['Tx Frames'])
        icmp2_count_physical = int(ApData.stream_stats['uut1_IPV6_ICMP_echoreply']['Tx Frames'])
        icmp3_count_physical = int(ApData.stream_stats['uut1_IPV6_ICMP_dest_unreach']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[3]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[4]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[5]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[6]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp2_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp2_count_physical, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[7]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp3_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp3_count_physical, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_IPV6_ICMP_time_exceed']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut1_IPV6_ICMP_echoreply']['Rx Frames']
        rx_count5 = ApData.stream_stats['uut1_IPV6_ICMP_dest_unreach']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[3]['sequence_number']: [tcp_count_physical, rx_count1],
                                                      seq[4]['sequence_number']: [udp_count_physical, rx_count2],
                                                      seq[5]['sequence_number']: [icmp1_count_physical, rx_count3],
                                                      seq[6]['sequence_number']: [icmp2_count_physical, rx_count4],
                                                      seq[7]['sequence_number']: [icmp3_count_physical, rx_count5]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.log.info("Un Configuring acl from Bundle interface")

        # ApData.acl_uut.set_acl_to_interface(access_list_name=bundle_aclname, address_family=bundle_add_family,
        #                                     direction=bundle_dir,
        #                                     interface=bundle_intf, mode="unconfig")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundleBundle']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.irfPhysical
class TestIPv4AclPhysicalBundleFlapwithCompress(AclBaseAp):

    def test_verify_IPv4_same_acl_on_Physical_Bundle_CompressLevel1(self):
        """

        This testcase Verify same ACL on both Physical and Bundle configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config ACL
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress  and Bundle Egress direction
            - Send traffic
            - Verify packet

        Configurations:
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)
        physical_intf = ApData.intf


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=ApData.intf, mode="config")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundleBundle']

        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        bundle_intf = ApData.intf
        bundle_dir = ApData.dir
        bundle_add_family = ApData.addr_family
        bundle__loc = loc
        bundle_aclname = ApData.aclname

        with pytest.allure.step('Shut the Physical interface'):
            ApData.uut1_ifmgr.shut(physical_intf)
            Helper.sleep(20, msg='waiting for interface and protocols to go '
                                 'down')
        with pytest.allure.step('Verify the Physical interface status'):
            ApData.uut1_ifmgr.verify_shut(physical_intf)

        with pytest.allure.step('Unshut the Physical interface'):
            ApData.uut1_ifmgr.noshut(physical_intf)
            self.success = True
            Helper.sleep(20, msg='waiting for Physical interface to come up')

        with pytest.allure.step('Verify the Physical interface status'):
            ApData.uut1_ifmgr.verify_noshut(physical_intf)

        with pytest.allure.step('Shut the Bundle interface'):
            ApData.uut1_ifmgr.shut(bundle_intf)
            Helper.sleep(20, msg='waiting for interface and protocols to go '
                                 'down')
        with pytest.allure.step('Verify the Bundle interface status'):
            ApData.uut1_ifmgr.verify_shut(bundle_intf)

        with pytest.allure.step('Unshut the Bundle interface'):
            ApData.uut1_ifmgr.noshut(bundle_intf)
            self.success = True
            Helper.sleep(20, msg='waiting for Bundle interface to come up')

        with pytest.allure.step('Verify the Bundle interface status'):
            ApData.uut1_ifmgr.verify_noshut(bundle_intf)


        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=None, location=lc)
        stream = ['uut2_v4_tcp_dscp_ttl_pl_bundle','uut2_v4_udp_dscp_ttl_pl_bundle','uut2_OSPF_Bundle','uut2_ICMP_Bundle',
                  'uu1_v4_TCP_dscp_ttl','uu1_v4_UDP_dscp_ttl','uut1_ICMPstream1','uut1_ICMP_echoreply']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        import pdb
        #pdb.set_trace()

        seq = ApData.acl_data['aclnames'][ApData.aclname]

        verifier_obj = []
        tcp_count_bundle = int(ApData.stream_stats['uut2_v4_tcp_dscp_ttl_pl_bundle']['Tx Frames'])
        udp_count_bundle = int(ApData.stream_stats['uut2_v4_udp_dscp_ttl_pl_bundle']['Tx Frames'])
        ospf_count_bundle = int(ApData.stream_stats['uut2_OSPF_Bundle']['Tx Frames'])
        icmp_count_bundle = int(ApData.stream_stats['uut2_ICMP_Bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count_bundle, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count_bundle, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(ospf_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(ospf_count_bundle, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[3]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp_count_bundle, extra=False),
                                               AclBaseAp.tolerance_value(icmp_count_bundle, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_v4_tcp_dscp_ttl_pl_bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_v4_udp_dscp_ttl_pl_bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_OSPF_Bundle']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut2_ICMP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count_bundle, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count_bundle, rx_count2],
                                                      seq[2]['sequence_number']: [ospf_count_bundle, rx_count3],
                                                      seq[3]['sequence_number']: [icmp_count_bundle, rx_count4]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundlePhysical']

        AclBaseAp._get_tcs_data(ApData)


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        physical_intf = ApData.intf
        physical_dir = ApData.dir
        physical_add_family = ApData.addr_family
        AclBaseAp._get_loc_int(ApData, physical_intf)
        physical_loc = ApData.hw_loc
        physical_aclname = ApData.aclname

        # ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
        #                                direction=ApData.dir,
        #                                interface=None, location=ApData.hw_loc)


        seq = ApData.acl_data['aclnames'][ApData.aclname]
        verifier_obj = []
        tcp_count_physical = int(ApData.stream_stats['uu1_v4_TCP_dscp_ttl']['Tx Frames'])
        udp_count_physical = int(ApData.stream_stats['uu1_v4_UDP_dscp_ttl']['Tx Frames'])
        icmp1_count_physical = int(ApData.stream_stats['uut1_ICMPstream1']['Tx Frames'])
        icmp_count_physical = int(ApData.stream_stats['uut1_ICMP_echoreply']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[4]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[5]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[6]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[7]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp_count_physical, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uu1_v4_TCP_dscp_ttl']['Rx Frames']
        rx_count2 = ApData.stream_stats['uu1_v4_UDP_dscp_ttl']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_ICMPstream1']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut1_ICMP_echoreply']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[4]['sequence_number']: [tcp_count_physical, rx_count1],
                                                      seq[5]['sequence_number']: [udp_count_physical, rx_count2],
                                                      seq[6]['sequence_number']: [icmp1_count_physical, rx_count3],
                                                      seq[7]['sequence_number']: [icmp_count_physical, rx_count4]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.log.info("Un Configuring acl from Bundle interface")

        ApData.acl_uut.set_acl_to_interface(access_list_name=bundle_aclname, address_family=bundle_add_family,
                                            direction=bundle_dir,
                                            interface=bundle_intf, mode="unconfig")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V4PhysicalBundleBundle']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.irfPhysical
class TestIPv6AclPhysicalBundleFlapwithCompress(AclBaseAp):

    def test_verify_IPv6_same_acl_on_Physical_Bundle_CompressLevel1(self):
        """

        This testcase Verify same ACL on both Physical and Bundle configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config ACL
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress  and Bundle Egress direction
            - Send traffic
            - Verify packet

        Configurations:
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        #pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)
        physical_intf = ApData.intf


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundleBundle']

        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,interface=ApData.intf, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        bundle_intf = ApData.intf
        bundle_dir = ApData.dir
        bundle_add_family = ApData.addr_family
        bundle__loc = loc
        bundle_aclname = ApData.aclname

        with pytest.allure.step('Unshut the Physical interface'):
            ApData.uut1_ifmgr.noshut(physical_intf)
            self.success = True
            Helper.sleep(20, msg='waiting for Physical interface to come up')

        with pytest.allure.step('Verify the Physical interface status'):
            ApData.uut1_ifmgr.verify_noshut(physical_intf)

        with pytest.allure.step('Shut the Bundle interface'):
            ApData.uut1_ifmgr.shut(bundle_intf)
            Helper.sleep(20, msg='waiting for interface and protocols to go '
                                 'down')
        with pytest.allure.step('Verify the Bundle interface status'):
            ApData.uut1_ifmgr.verify_shut(bundle_intf)

        with pytest.allure.step('Unshut the Bundle interface'):
            ApData.uut1_ifmgr.noshut(bundle_intf)
            self.success = True
            Helper.sleep(20, msg='waiting for Bundle interface to come up')

        with pytest.allure.step('Verify the Bundle interface status'):
            ApData.uut1_ifmgr.verify_noshut(bundle_intf)
        for lc in loc:
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,direction=ApData.dir,interface=None, location=lc)
        #stream = ['uut2_v4_tcp_dscp_ttl_pl_bundle','uut2_v4_udp_dscp_ttl_pl_bundle','uut2_OSPF_Bundle','uut2_ICMP_Bundle','uu1_v4_TCP_dscp_ttl','uu1_v4_UDP_dscp_ttl','uut1_ICMPstream1','uut1_ICMP_echoreply']

        stream = ['uut2_IPV6_TCP_Bundle','uut2_IPV6_UDP_Bundle','uut2_V6_pim_dscp_bundle',
                  'uut1_IPV6_TCP_Phy','uut1_IPV6_UDP_Phy','uut1_IPV6_ICMP_time_exceed',
                  'uut1_IPV6_ICMP_echoreply','uut1_IPV6_ICMP_dest_unreach']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        seq = ApData.acl_data['aclnames'][ApData.aclname]
        import pdb
        #pdb.set_trace()

        verifier_obj = []
        tcp_count_bundle = int(ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Tx Frames'])
        udp_count_bundle = int(ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Tx Frames'])
        pim_count_bundle = int(ApData.stream_stats['uut2_V6_pim_dscp_bundle']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count_bundle, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count_bundle, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[2]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(pim_count_bundle, extra=False),
                                                                AclBaseAp.tolerance_value(pim_count_bundle, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_IPV6_TCP_Bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_IPV6_UDP_Bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_V6_pim_dscp_bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count_bundle, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count_bundle, rx_count2],
                                                      seq[2]['sequence_number']: [pim_count_bundle, rx_count3],
                                                      },
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundlePhysical']

        AclBaseAp._get_tcs_data(ApData)


        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        physical_intf = ApData.intf
        physical_dir = ApData.dir
        physical_add_family = ApData.addr_family
        AclBaseAp._get_loc_int(ApData, physical_intf)
        physical_loc = ApData.hw_loc
        physical_aclname = ApData.aclname

        # ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
        #                                direction=ApData.dir,
        #                                interface=None, location=ApData.hw_loc)


        seq = ApData.acl_data['aclnames'][ApData.aclname]
        verifier_obj = []
        tcp_count_physical = int(ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames'])
        udp_count_physical = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])
        icmp1_count_physical = int(ApData.stream_stats['uut1_IPV6_ICMP_time_exceed']['Tx Frames'])
        icmp2_count_physical = int(ApData.stream_stats['uut1_IPV6_ICMP_echoreply']['Tx Frames'])
        icmp3_count_physical = int(ApData.stream_stats['uut1_IPV6_ICMP_dest_unreach']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[3]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(tcp_count_physical, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[4]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(udp_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[5]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp1_count_physical, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[6]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp2_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp2_count_physical, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[7]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(icmp3_count_physical, extra=False),
                                               AclBaseAp.tolerance_value(icmp3_count_physical, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut1_IPV6_ICMP_time_exceed']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut1_IPV6_ICMP_echoreply']['Rx Frames']
        rx_count5 = ApData.stream_stats['uut1_IPV6_ICMP_dest_unreach']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[3]['sequence_number']: [tcp_count_physical, rx_count1],
                                                      seq[4]['sequence_number']: [udp_count_physical, rx_count2],
                                                      seq[5]['sequence_number']: [icmp1_count_physical, rx_count3],
                                                      seq[6]['sequence_number']: [icmp2_count_physical, rx_count4],
                                                      seq[7]['sequence_number']: [icmp3_count_physical, rx_count5]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")

        ApData.log.info("Un Configuring acl from Bundle interface")

        # ApData.acl_uut.set_acl_to_interface(access_list_name=bundle_aclname, address_family=bundle_add_family,
        #                                     direction=bundle_dir,
        #                                     interface=bundle_intf, mode="unconfig")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundlePhysical']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6PhysicalBundleBundle']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")



@pytest.mark.irfBundle
class TestIpv4TcpPerBundleSubEgressCompress(AclBaseAp):

    def test_ipv4_tcp_per_bundle_sub_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on egress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc8']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['uut1_TCP_bunsub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_bunsub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_bunsub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc8']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,mode="unconfig")




@pytest.mark.irfCompressOld
class TestIpv4TcpPerPhySubEgressCompress(AclBaseAp):

    def test_ipv4_tcp_per_physub_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on egress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in egress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc6']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames']
        verifier_obj = []
        ##
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc6']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.irfCompressOld
class TestIpv4TcpHostPerPhysubEgressCompress(AclBaseAp):

    def test_ipv4_tcp_host_per_physub_egress_compress_level_1(self):
        """
        Ipv4 TCP(Host) permit Acl on egress Sub Interface.

        This test will verify ACL for tcp traffic from host to host, applied on physical sub interface in egress direction compress_level = 1.

        Test Procedure:
            - Config IPv4 ACL with Tcp host.
            - Attach IPv4 ACL to bundle interface on ingress direction compress_level = 1
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP host

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # TCP traffic with sub interface  egress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=1, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=1, mode="unconfig")

    def test_ipv4_tcp_host_per_physub_egress_compress_level_3(self):
        """
        Ipv4 TCP(Host) permit Acl on egress Sub Interface.

        This test will verify ACL for tcp traffic from host to host, applied on physical sub interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Tcp host.
            - Attach IPv4 ACL to bundle interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP host

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # TCP traffic with sub interface  egress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


#@pytest.mark.irfCompressAtomic

@pytest.mark.irfPhysical
class TestAtomicreplacementipv4Compress(AclBaseAp):

    def test_atomic_replacement_ipv4(self):

        """
        Atomic Replacement of Ipv4  ACL on Ingress and Egress PHY Interface.

        This test will have multiple Ipv4 aces with the acl names attached to Ingress and Egress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.

        Test Procedure:
            1. This Test will do Create the Multiple IPv4  Aces on Ingress and Egress.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.

        Configurations:
            - Acl with dscp,precedence,ttl values.

        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.

        Triggers:
            - None

        """

        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_atomic', 'Tc_replace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_atomic']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_TCP_DSCP_AF22', 'uut1_Ospf_Phy', 'uut1_ICMP_redirect']
        seqn = ['11', '23', '33']

        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_replace']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer1_In_TCP_Prec', 'peer1_In_TCP_flag_prec', 'peer1_In_UDP_Phy', 'peer1_In_Ospf_Phy',
                        'peer1_In_ICMP_echoreply', 'peer1_In_ICMP_Phy']
        seqn = ['50', '55', '57', '60', '63', '65']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

        ####################################################For Atomic replacement###########################################################
        list1 = ['Tc_dscp', 'Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_TCP_DSCP_AF22', 'uut1_Ospf_Phy', 'uut1_ICMP_redirect']
        seqn = ['11', '23', '33']

        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer1_In_TCP_Prec', 'peer1_In_TCP_flag_prec', 'peer1_In_UDP_Phy', 'peer1_In_Ospf_Phy',
                        'peer1_In_ICMP_echoreply', 'peer1_In_ICMP_Phy']
        seqn = ['50', '55', '57', '60', '63', '65']
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

    def teardown_class(self):
        list1 = ['Tc_dscp', 'Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")


#@pytest.mark.irfCompressAtomic
@pytest.mark.irfPhysical
class TestAtomicreplacementipv6Compress(AclBaseAp):

    def test_atomic_replacement_ipv6(self):

        """
        Atomic Replacement of Ipv6  ACL on Ingress and Egress PHY Interface.

        This test will have multiple Ipv6 aces with the acl names attached to Ingress and Egress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.

        Test Procedure:
            1. This Test will do Create the Multiple IPv6  Aces on Ingress and Egress.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.

        Configurations:
            - Acl with Precedence,dscp.

        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.

        Triggers:
            - None

        """

        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_atomicipv6', 'Tc_replaceipv6']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_atomicipv6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream_start = ['uut1_IPV6_ICMP_time_exceed', 'uut1_IPV6_ICMP_dest_unreach']
        seqn = ['3', '5']
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_replaceipv6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream_start = ['peer1_In_IPV6_ICMP_timeexceed', 'peer1_In_IPV6_ICMP_Phy']
        seqn = ['8', '11']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

        ####################################################For Atomic replacement###########################################################
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_IPV6_ICMP_time_exceed', 'uut1_IPV6_ICMP_dest_unreach']
        seqn = ['3', '5']

        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer1_In_IPV6_ICMP_timeexceed', 'peer1_In_IPV6_ICMP_Phy']
        seqn = ['8', '11']
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seqn[seq],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            """
            Verify hardware hit count on interface 
            """
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seqn[seq]: [matches, rx_count1]}, location=[ApData.hw_loc])

    def teardown_class(self):
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")


@pytest.mark.irfCompressOld
class TestIpv4NetworkIngressAclNetworkAddressCompresslevel3(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL

        Apply acl to an Ingress interface with compress and verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.20.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='120.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkIngressAclNetworkAddressCompresslevel3(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Ingress Phy intf with Compress Level 3

        This testcase Verify Object group with network type  and enabling Hybrid ACL with compression level 3 on Ingress direction

        Test Procedures:
            - Config Ipv4 Network Object group with Network Address parameter
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on expected ACE
            - clean config


        Configurations:
            - create object group with network type
            - config ACL
            - Attach ACL to interface and enable compress level 3

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        ACL config on phy
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_PhySub']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.20.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='120.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.irfCompressOld
class TestIpv4NetworkEgressAclNetworkAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL

        Apply acl to an Egress interface with compressand verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkEgressAclNetworkAddressCompressLevel3(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Egress Phy intf with Compress Level 3

        This testcase Verify Object group with network type  and enabling Hybrid ACL with compression level 3 on Egress direction

        Test Procedures:
            - Config Ipv4 Network Object group with Network Address parameter
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on expected ACE
            - clean config


        Configurations:
            - create object group with network type
            - config ACL
            - Attach ACL to interface and enable compress level 3

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_Prec_1_stream', 'uut1_TCPstream2_PSH_Flag', 'uut1_TCP_TTL10', 'uut1_TCP_DSCP_AF22',
                  'uut1_TCPstream1', 'uut1_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_stream_total = int(
            ApData.stream_stats['uut1_Prec_1_stream']['Tx Frames']) + int(
            ApData.stream_stats['uut1_TCPstream2_PSH_Flag']['Tx Frames']) + int(
            ApData.stream_stats['uut1_TCP_TTL10']['Tx Frames']) + int(
            ApData.stream_stats['uut1_TCP_DSCP_AF22']['Tx Frames']) + int(
            ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_stream_total = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(tcp_stream_total, extra=False),
                                               AclBaseAp.tolerance_value(tcp_stream_total, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(
                                               AclBaseAp.tolerance_value(udp_stream_total, extra=False),
                                               AclBaseAp.tolerance_value(udp_stream_total, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_tcp_stream_total = int(
            ApData.stream_stats['uut1_Prec_1_stream']['Rx Frames']) + int(
            ApData.stream_stats['uut1_TCPstream2_PSH_Flag']['Rx Frames']) + int(
            ApData.stream_stats['uut1_TCP_TTL10']['Rx Frames']) + int(
            ApData.stream_stats['uut1_TCP_DSCP_AF22']['Rx Frames']) + int(
            ApData.stream_stats['uut1_TCPstream1']['Rx Frames'])
        rx_udp_stream_total = int(ApData.stream_stats['uut1_UDPstream1']['Rx Frames'])
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_stream_total, rx_tcp_stream_total],
                                                  seq[1]['sequence_number']: [udp_stream_total, rx_udp_stream_total]},
                                         location=[ApData.hw_loc], add_ace=True)

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


#####################################################################################
@pytest.mark.irfCompressOld
class TestIpv4NetworkPhySubEgressAclNetworkAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL

        Apply acl to an Egress interface with compressand verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkPhySubEgressAclNetworkAddressCompressLevel3(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Egress PhySub intf with Compress Level 3

        This test-case verifies Object group and hybrid acl compression level at 3 enable on interface

        Test Procedure:
            - Config Ipv4 Network Object group with Network Address parameter
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to PhySub interface on Egress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_stream_total = int(ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames'])
        udp_stream_total = int(ApData.stream_stats['uut1_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_stream_total)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_stream_total)))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_stream_total, rx_count1],
                                                  seq[1]['sequence_number']: [udp_stream_total, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.irfCompressOld
class TestIPv6NetworkIngressAclHostAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL


        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclHostAddressCompressLevel3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf with Compress Level 3

        This test-case verifies Object group and hybrid acl compression level at 3 enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to PhySub interface on Ingress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")

@pytest.mark.irfCompressOld
class TestIPv6NetworkEgressAclHostAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL

        Apply acl to an Egress interface with compress and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkEgressAclHostAddressCompressLevel3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Egress Phy intf with Compress Level 3

        This test-case verifies Object group and hybrid acl compression level at 3 enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Phy', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


#############################################################################################################
@pytest.mark.irfCompressOld
class TestIPv6NetworkPhySubEgressAclHostAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL


        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkPhySubEgressAclHostAddressCompressLevel3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Egress PhySub intf with Compress Level3

        This test-case verifies Object group and hybrid acl compression level at 3  enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to PhySub interface on Egress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupEgressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Physub', 'uut1_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Physub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.irfCompressOld
class TestIPv6NetworkIngressAclHostAddress(AclBaseAp):

    def setup_class(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclHostAddress(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf

        This test-case verifies Object group with Network type , ACE uses object group and allow to match host.

        Test Procedure:
            - Config Ipv6 Network Object group with Host Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.irfCompressOld
class TestIPv6NetworkIngressAclNetworkAddress(AclBaseAp):
    def setup_class(self):
        """
        IPV6 Network Object-Group parameter Network Address type set on Ingress Phy intf
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclNetworkAddress(self):
        """
        IPV6 Network Object-Group parameter Network Address type set on Ingress Phy intf

        This test-case verifies Object group with Network type , ACE uses object group and allow to match host fallin to network address specified.

        Test Procedure:
            - Config Ipv6 Network Object group with network Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        ACL applying in Phy Sub         
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.irfBviOld
class TestBVIipv4SubPRECDSCPTTLIngressompress(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["peer2_In_tcp_bvi 21", "peer2_In_udp_bvi 22",
                              "peer2_In_ospf_bvi 23", "peer2_In_icmp_bvi 24", "peer2_In_icmp_bvi_redirect 25"])
    def test_bvi_ipv4_sub_prec_dscp_ttl_ingress_interface(self, stream):
        """
        Multiple Ipv4 Aces which has DSCP,PRECEDENCE,Values and ICMP Type on BVI SUB-Interface for Ingress.

        This has Multiple Ipv4 deny aces like DSCP,PRECEDENCE Values,ICMP TYPE which are Attached
        to BVI Interface of Ingress Direction and traffic is passed with single stream  to hit the match count.

        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,PRECEDENCE Values,ICMP TYPE
            - Attach ACL to BVI Interface on Ingress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.

        Configurations:
            - Acl with DSCP,PRECEDENCE,Values and ICMP Type.

        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.

        Triggers:
            - None

        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['bvi_In']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_In']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=str(seq),
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq: [matches, rx_count1]}, location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        list1 = ['bvi_In']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")


@pytest.mark.irfBvi
class TestIPv4AclBviIngressTCPUDPICMPOSPFCompress(AclBaseAp):

    def test_verify_IPv4_acl_on_BVI_Ingress_CompressLevel1(self):
        """

        This testcase Verify same ACL on both Physical and Bundle configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config ACL
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress  and Bundle Egress direction
            - Send traffic
            - Verify packet

        Configurations:
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        # pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_In']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")

        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        # stream = ['uut2_v4_tcp_dscp_ttl_pl_bundle','uut2_v4_udp_dscp_ttl_pl_bundle','uut2_OSPF_Bundle','uut2_ICMP_Bundle',
        #'uu1_v4_TCP_dscp_ttl', 'uu1_v4_UDP_dscp_ttl', 'uut1_ICMPstream1', 'uut1_ICMP_echoreply']

        stream = ["peer2_In_tcp_bvi", "peer2_In_udp_bvi", "peer2_In_ospf_bvi", "peer2_In_icmp_bvi", "peer2_In_icmp_bvi_redirect"]

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        import pdb
        # pdb.set_trace()

        seq = ApData.acl_data['aclnames'][ApData.aclname]

        verifier_obj = []
        tcp_count_bvi = int(ApData.stream_stats['peer2_In_tcp_bvi']['Tx Frames'])
        udp_count_bvi = int(ApData.stream_stats['peer2_In_udp_bvi']['Tx Frames'])
        ospf_count_bvi = int(ApData.stream_stats['peer2_In_ospf_bvi']['Tx Frames'])
        icmp_count_bvi = int(ApData.stream_stats['peer2_In_icmp_bvi']['Tx Frames'])
        icmp1_count_bvi = int(ApData.stream_stats['peer2_In_icmp_bvi_redirect']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
        sequence_number = seq[0]['sequence_number'],matches = CyDiff.Range(AclBaseAp.tolerance_value(tcp_count_bvi, extra=False),
                               AclBaseAp.tolerance_value(tcp_count_bvi, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
        sequence_number = seq[1]['sequence_number'],matches = CyDiff.Range(AclBaseAp.tolerance_value(udp_count_bvi, extra=False),
                               AclBaseAp.tolerance_value(udp_count_bvi, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number = seq[2]['sequence_number'],
                             matches = CyDiff.Range(AclBaseAp.tolerance_value(ospf_count_bvi, extra=False),
                               AclBaseAp.tolerance_value(ospf_count_bvi, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                    sequence_number = seq[3]['sequence_number'],matches = CyDiff.Range(
                        AclBaseAp.tolerance_value(icmp_count_bvi, extra=False),
                        AclBaseAp.tolerance_value(icmp_count_bvi, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                sequence_number = seq[3]['sequence_number'],matches = CyDiff.Range(
                                    AclBaseAp.tolerance_value(icmp1_count_bvi, extra=False),
                                    AclBaseAp.tolerance_value(icmp1_count_bvi, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut2_v4_tcp_dscp_ttl_pl_bundle']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut2_v4_udp_dscp_ttl_pl_bundle']['Rx Frames']
        rx_count3 = ApData.stream_stats['uut2_OSPF_Bundle']['Rx Frames']
        rx_count4 = ApData.stream_stats['uut2_ICMP_Bundle']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count_bvi, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count_bvi, rx_count2],
                                                      seq[2]['sequence_number']: [ospf_count_bvi, rx_count3],
                                                      seq[3]['sequence_number']: [icmp_count_bvi, rx_count4],
                                                      seq[3]['sequence_number']: [icmp1_count_bvi, rx_count4]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")
    def teardown_class(self):

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_In']
        AclBaseAp._get_tcs_data(ApData)
        interface_name = ApData.acl_data['test_args']['apply_intf']['bvi_In']['interface_name']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=interface_name, mode="unconfig")

@pytest.mark.irfBvi
class TestIPv6AclBviIngressGrePimIcmpCompress(AclBaseAp):

    def test_verify_IPv6_acl_on_BVI_Ingress_CompressLevel1(self):
        """

        This testcase Verify same ACL on both Physical and Bundle configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config ACL
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress  and Bundle Egress direction
            - Send traffic
            - Verify packet

        Configurations:
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        import pdb
        # pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_Ipv6_ingress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")

        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        # stream = ['uut2_v4_tcp_dscp_ttl_pl_bundle','uut2_v4_udp_dscp_ttl_pl_bundle','uut2_OSPF_Bundle','uut2_ICMP_Bundle',
        #'uu1_v4_TCP_dscp_ttl', 'uu1_v4_UDP_dscp_ttl', 'uut1_ICMPstream1', 'uut1_ICMP_echoreply']

        stream = ["peer2_In_V6_gre_bvi", "peer2_In_V6_pim_bvi", "peer2_In_V6_icmp_pack_too_big_bvi", "peer2_In_V6_icmp_echo_replay_bvi"]

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        import pdb
        # pdb.set_trace()

        seq = ApData.acl_data['aclnames'][ApData.aclname]

        verifier_obj = []
        gre_count_bvi = int(ApData.stream_stats['peer2_In_V6_gre_bvi']['Tx Frames'])
        pim_count_bvi = int(ApData.stream_stats['peer2_In_V6_pim_bvi']['Tx Frames'])
        icmp_count_bvi = int(ApData.stream_stats['peer2_In_V6_icmp_pack_too_big_bvi']['Tx Frames'])
        icmp1_count_bvi = int(ApData.stream_stats['peer2_In_V6_icmp_echo_replay_bvi']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
        sequence_number = seq[0]['sequence_number'],matches = CyDiff.Range(AclBaseAp.tolerance_value(gre_count_bvi, extra=False),
                               AclBaseAp.tolerance_value(gre_count_bvi, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
        sequence_number = seq[1]['sequence_number'],matches = CyDiff.Range(AclBaseAp.tolerance_value(pim_count_bvi, extra=False),
                               AclBaseAp.tolerance_value(pim_count_bvi, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number = seq[2]['sequence_number'],
                             matches = CyDiff.Range(AclBaseAp.tolerance_value(icmp_count_bvi, extra=False),
                               AclBaseAp.tolerance_value(icmp_count_bvi, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                    sequence_number = seq[3]['sequence_number'],matches = CyDiff.Range(
                        AclBaseAp.tolerance_value(icmp1_count_bvi, extra=False),
                        AclBaseAp.tolerance_value(icmp1_count_bvi, extra=True))))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer2_In_V6_gre_bvi']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer2_In_V6_pim_bvi']['Rx Frames']
        rx_count3 = ApData.stream_stats['peer2_In_V6_icmp_pack_too_big_bvi']['Rx Frames']
        rx_count4 = ApData.stream_stats['peer2_In_V6_icmp_echo_replay_bvi']['Rx Frames']


        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [gre_count_bvi, rx_count1],
                                                      seq[1]['sequence_number']: [pim_count_bvi, rx_count2],
                                                      seq[2]['sequence_number']: [icmp_count_bvi, rx_count4],
                                                      seq[3]['sequence_number']: [icmp1_count_bvi, rx_count4]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen for bundle interface")
    def teardown_class(self):

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_Ipv6_ingress']
        AclBaseAp._get_tcs_data(ApData)
        interface_name = ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_Ipv6_ingress']['interface_name']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=interface_name, mode="unconfig")

@pytest.mark.irfCompressBvi
class TestBVIipV6SubPRECDSCPTTLEgressINTERFACECompress(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut2_ipv6_tcp_bvi 1", "uut2_ipv6_udp_bvi 2",
                              "uut2_ipv6_icmp_dest_unreach 5", "uut2_ipv6_icmp_echo_reply 4",
                              "uut2_ipv6_icmp_time_exceed 3"])
    def test_bvi_ipv6_sub_prec_dscp_ttl_egress_interface(self, stream):
        """
        Multiple Ipv6 Aces which has DSCP,PRECEDENCE Values,ICMP TYPE on BVI SUB-Interface for Egress.

        This has Multiple Ipv6 deny aces like DSCP,PRECEDENCE Values,ICMP TYPE which are Attached
        to BVI Interface of Egress Direction and traffic is passed with single stream  to hit the match count.

        Test Procedure:
            - Config Multiple IPv6 ACL which has DSCP,PRECEDENCE Values,ICMP TYPE
            - Attach ACL to BVI Interface on Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.

        Configurations:
            - Acl with DSCP,PRECEDENCE Values,ICMP TYPE.

        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.

        Triggers:
            - None

        """

        #
        #####################################################Attaching to the interface #################################################
        list1 = ['bvi_Ipv6_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")

        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_Ipv6_Egress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=str(seq),
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={seq: [matches, rx_count1]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        list1 = ['bvi_Ipv6_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")


########################## CompressACL Ends########################################


@pytest.mark.ls
class TestIPv6NetworkAclGroupIngressOnBundleCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 irfan port and network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='gt',
            port_number=1023,
            mode="config")
        for network in ['120:1:2::/64','120:1:3::/64','137::/64','130:1::/64','120:1::/64']:
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='network_V6_object_group',
                network_address=network,
                host=None,
                range=None,
                object_group=None,
                mode="config")
        # for network in ['120.1.1.0/24', '30.0.10.0/24', '91.1.1.0/24']:
        #     acl = ApData.acl_uut.set_network_object_group_acl(
        #         address_family='ipv4',
        #         obj_group_name='network_object_group_host',
        #         network_address='120.1.1.0/24',
        #         host=None,
        #         range=None,
        #         object_group=None,
        #         mode="config")

        """
        Apply object group to ACE 
        """
        aclname = "ipv6_ob_network_port_Bundle_main"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkAclGrouoEqualtoCompressLevel1(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupIngressAclBun']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uut1_IPv6_main', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPv6_main']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_IPv6_main']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def test_verify_IPv6NetworkAclGrouoEqualtoCompressLevel3(self):
        """
        IPV4 Port Object-Group parameter Port number and EqualTo option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure:
            - Config Port Object group with Equal to 1024 port number
            - Config Ipv4 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Egress direction
            - Send traffic
            - Verify packet with Equal to port no 1024 hit ACE

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['V6NetworkPortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        import pdb
        #pdb.set_trace()
        stream = ['uut1_IPv6_main', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPv6_main']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['uut1_IPv6_main']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                             traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                      seq[1]['sequence_number']: [udp_count, rx_count2]},
                                             location=[ApData.hw_loc], add_ace=True)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='compress_port_eq_1024',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")
@pytest.mark.Feature('ObjectGroups')
class TestIPv6PortIngressAclHostAddressGreaterThan(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 port object group and create ACL
        
        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='gt',
            port_number=1023,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6PortIngressAclHostAddressGreaterThan(self):
        """
        IPV6 Port Object-Group parameter Port number and GreaterThan option type set on Ingress Phy intf
        
        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Greater than specified port number

        Test Procedure:
            - Config Port Object group with Greater than 1023 port number 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic 
            - Verify packet with Greater than port no 1023 hit ACE  
        
        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        Apply acl to Phy interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='gt',
            port_number=1023,
            mode="unconfig")


#
@pytest.mark.Feature('ObjectGroups')
class TestIPv6PortIngressAclHostAddressLesserThan(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='lt',
            port_number=1025,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6_Port_Ingress_Acl_Host_Address_Lesser_Than(self):
        """
        IPV6 Port Object-Group parameter Port number and LesserThan option type set on Ingress Phy intf
        
        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Lesser than specified port number

        Test Procedure:
            - Config Port Object group with  Lesser than 1025 port number 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic 
            - Verify packet with lesser than port no 1025 hit ACE  

        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='lt',
            port_number=1025,
            mode="unconfig")


@pytest.mark.Feature('ObjectGroups')
class TestIPv6PortIngressAclHostAddressEqualto(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='eq',
            port_number=1024,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6PortIngressAclHostAddressEqualto(self):
        """
        IPV6 Port Object-Group parameter Port number and equal to option type set on Ingress Phy intf
        
        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Equale to specified port number

        Test Procedure :
            - Config Port Object group with  Equal to 1024 port number 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic 
            - Verify packet with port no 1024 hit ACE  

        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='eq',
            port_number=1024,
            mode="unconfig")


@pytest.mark.Feature('ObjectGroups')
class TestIPv6PortIngressAclHostAddressNotEqualto(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='neq',
            port_number=1023,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6PortIngressAclHostAddressNotEqualto(self):
        """
        IPV6 Port Object-Group parameter Port number and Not Equal to option type set on Ingress Phy intf
        
        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Not Equale to specified port number
        
        Test Procedures:
            - Config Port Object group with Not equal to for specified port no 
            - Config Ipv4 ACL with ACE that contains Port object group 
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic with different port number
            - Verify hardware hit for packets which Not equal to for specified port no on expected ACE 
            - clean config 
    
        Configurations: 
            - create object group port type
            - config ACL 
            - Attach ACL to interface 
            
        Verifications: 
            - Verify hardware hit count on interface 

        Triggers:
            - None


        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        Apply acl to Phy Sub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        import pdb
        pdb.set_trace()
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='neq',
            port_number=1023,
            mode="unconfig")

# Start of ls
@pytest.mark.ls
class TestIpv4TcpPerPhyIngressCompressed(AclBaseAp):

    def test_ipv4_tcp_per_phy_ingress_compress_level_1(self):
        """ irfan
        Ipv4 TCP Acl on ingress physical Interface with compressed level 1.

        This test will verify ACL for Tcp traffic from any to any, applied on phys interface in ingress direction.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to Phy interface on Ingress direction with compress level 1
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        # TCP traffic with physical interface ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc1']
        AclBaseAp._get_tcs_data(ApData)
        Helper.sleep(60, msg='waiting for configuration to take place')

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=int(matches)))
        rx_count = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.verify_acl_hardware_hit_count(access_list_name=ApData.aclname,
                                                         addr_family=ApData.addr_family, direction=ApData.dir,
                                                         acl=ApData.acl_data['aclnames'][ApData.aclname], traffic={
                    ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                                         location=[ApData.hw_loc],
                                                         active_rp=ApData.UUT1.inventory.get_xr_active_rp(),
                                                         expected_data_obj=verifier_obj, interface=None)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc1']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def test_ipv4_tcp_per_phy_ingress_compress_level_3(self):
        """ irfan
        Ipv4 TCP Acl on ingress physical Interface with compressed level 3.

        This test will verify ACL for Tcp traffic from any to any, applied on phys interface in ingress direction.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to Phy interface on Ingress direction with compress level 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        # TCP traffic with physical interface ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc1']
        AclBaseAp._get_tcs_data(ApData)
        Helper.sleep(60, msg='waiting for configuration to take place')

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=int(matches)))
        rx_count = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        try:
            ApData.acl_uut.verify_acl_hardware_hit_count(access_list_name=ApData.aclname,
                                                         addr_family=ApData.addr_family, direction=ApData.dir,
                                                         acl=ApData.acl_data['aclnames'][ApData.aclname], traffic={
                    ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                                         location=[ApData.hw_loc],
                                                         active_rp=ApData.UUT1.inventory.get_xr_active_rp(),
                                                         expected_data_obj=verifier_obj, interface=None)
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc1']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpPerPhyEgressCompressed(AclBaseAp):

    def test_ipv4_tcp_per_phy_egress_compress_leve1_1(self):
        """
        Ipv4 TCP Acl on egress physical Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on phys interface in egress direction compress_leve1 1.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to Phy interface on egress direction compress leve1 1
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc2']
        AclBaseAp._get_tcs_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream = ['uut1_TCPstream1']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc2']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def test_ipv4_tcp_per_phy_egress_compress_leve1_3(self):
        """
        Ipv4 TCP Acl on egress physical Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on phys interface in egress direction compress_leve1 3.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to Phy interface on egress direction compress leve1 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc2']
        AclBaseAp._get_tcs_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream = ['uut1_TCPstream1']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc2']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpPerBundleIngressCompress(AclBaseAp):

    def test_ipv4_tcp_per_bundle_ingress_compress_level_1(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Bundle interface in ingress direction compress_level 1.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle interface on ingress direction compress_level 1
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc3']
        AclBaseAp._get_bun_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="config")

        stream = ['peer2_In_TCP_Bundle']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer2_In_TCP_Bundle']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer2_In_TCP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc3']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="unconfig")

    def test_ipv4_tcp_per_bundle_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Bundle interface in ingress direction compress_level 3.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle interface on ingress direction compress_level 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc3']
        AclBaseAp._get_bun_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="config")

        stream = ['peer2_In_TCP_Bundle']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer2_In_TCP_Bundle']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer2_In_TCP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc3']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpPerBundleEgressCompress(AclBaseAp):

    def test_ipv4_tcp_per_bundle_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on egress Bundle Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Bundle interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        # TCP traffic with bundle interface egress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc4']
        AclBaseAp._get_bun_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,  mode="config")
        stream = ['uut2_TCP_Bundle']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut2_TCP_Bundle']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut2_TCP_Bundle']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.bundle_members_location[0],
                                                       ApData.bundle_members_location[1]])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc4']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.sf
class TestIpv4TcpPerPhySubIngressCompress(AclBaseAp):

    def test_ipv4_tcp_per_physub_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc5']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.hw_loc])
        except Exception as e:
            raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc5']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpPerPhySubEgressCompress(AclBaseAp):

    def test_ipv4_tcp_per_physub_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on egress Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on Phy sub interface in egress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any to any
            - Attach IPv4 ACL to phy sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc6']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames']
        verifier_obj = []
        ##
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc6']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpHostPerPhysubEgressCompress(AclBaseAp):

    def test_ipv4_tcp_host_per_physub_egress_compress_level_1(self):
        """
        Ipv4 TCP(Host) permit Acl on egress Sub Interface.

        This test will verify ACL for tcp traffic from host to host, applied on physical sub interface in egress direction compress_level = 1.

        Test Procedure:
            - Config IPv4 ACL with Tcp host.
            - Attach IPv4 ACL to bundle interface on ingress direction compress_level = 1
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP host

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # TCP traffic with sub interface  egress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=1, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=1, mode="unconfig")

    def test_ipv4_tcp_host_per_physub_egress_compress_level_3(self):
        """
        Ipv4 TCP(Host) permit Acl on egress Sub Interface.

        This test will verify ACL for tcp traffic from host to host, applied on physical sub interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Tcp host.
            - Attach IPv4 ACL to bundle interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type TCP host

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # TCP traffic with sub interface  egress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc22']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpPerBundleSubIngressCompress(AclBaseAp):

    def test_ipv4_tcp_per_bundle_sub_ingress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc7']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['peer1_In_TCP_BunSub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_TCP_BunSub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer1_In_TCP_BunSub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc7']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4TcpPerBundleSubEgressCompress(AclBaseAp):

    def test_ipv4_tcp_per_bundle_sub_egress_compress_level_3(self):
        """
        Ipv4 TCP permit Acl on egress Bundle Sub Interface.

        This test will verify ACL for Tcp traffic from any to any, applied on bundle sub interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc8']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['uut1_TCP_bunsub']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_TCP_bunsub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_TCP_bunsub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc8']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.sf
class TestIpv4UdpPerPhyIngressCompress(AclBaseAp):

    def test_ipv4_udp_per_phy_ingress_compress_level_3(self):
        """
        Ipv4 UDP permit Acl on ingress Physical Interface.

        This test will verify ACL for Udp traffic from any to any, applied on phy interface in ingress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any to any
            - Attach IPv4 ACL to Phy interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with UDP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        # UDP traffic with physical interface ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc9']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc9']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4UdpPerPhyEgressCompress(AclBaseAp):

    def test_ipv4_udp_per_phy_egress(self):
        """
        Ipv4 UDP permit Acl on egress Physical Interface.

        This test will verify ACL for Udp traffic from any to any, applied on phy interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any any
            - Attach IPv4 ACL to Phy interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type UDP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # UDP traffic with physical interface egress direction

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc10']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=str((matches))))
        rx_count = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc10']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.newIrfan
class TestIpv4MultipleAcePerDenyPhyEgressCompress(AclBaseAp):

    def test_ipv4_multiple_ace_phy_egress(self):
        """
        Ipv4 UDP permit Acl on egress Physical Interface.

        This test will verify ACL for Udp traffic from any to any, applied on phy interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any any
            - Attach IPv4 ACL to Phy interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type UDP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # UDP traffic with physical interface egress direction

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc10']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                           matches=str((matches))))
        rx_count = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc10']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")



@pytest.mark.ls
class TestIpv4UdpPerBundleIngressCompress(AclBaseAp):

    def test_ipv4_udp_per_bundle_ingress_compress_level_3(self):
        """
        Ipv4 UDP permit Acl on  ingress direction to Bundle Interface.

        This test will verify ACL for Udp traffic from any to any, applied on bundle interface in ingress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any to any
            - Attach IPv4 ACL to bundle interface on ingress direction
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with UDP any to aany

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc11']
        AclBaseAp._get_bun_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['peer2_In_UDP_Bundle']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)

        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer2_In_UDP_Bundle']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer2_In_UDP_Bundle']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc11']
        AclBaseAp._get_bun_data(ApData)
        ApData.intf = ApData.interfaces[ApData.intfl].name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4UdpPerBundleEgressCompress(AclBaseAp):

    def test_ipv4_udp_per_bundle_egress_compress_level_3(self):
        """
        IPv4 UDP permit Acl on  egress direction to Bundle Interface.

        This test will verify ACL for Udp traffic from any to any, applied on bundle interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any to any
            - Attach IPv4 ACL to Bundle interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type UDP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc12']
        AclBaseAp._get_bun_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        stream = ['uut2_UDP_Bundle']
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut2_UDP_Bundle']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut2_UDP_Bundle']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc12']
        AclBaseAp._get_bun_data(ApData)
        ApData.intf = ApData.interfaces[ApData.intfl].name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.ls
class TestIpv4UdpPerBundleSubIngressCompress(AclBaseAp):

    def test_ipv4_udp_per_bundle_sub_ingress_compress_level_3(self):
        """
        Ipv4 UDP permit Acl on  ingress Bundle Sub Interface.

        This test will verify ACL for Udp traffic from any to any, applied on bundle  sub interface in ingress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any any
            - Attach IPv4 ACL to bundle sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type UDP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc15']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        stream = ['peer1_In_UDP_BunSub']
        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_UDP_BunSub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer1_In_UDP_BunSub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc15']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIpv4UdpPerBundleSubEgressCompress(AclBaseAp):

    def test_ipv4_udp_per_bundle_sub_egress_compress_level_3(self):
        """
        Ipv4 UDP permit Acl on  egress Bundle Sub Interface.

        This test will verify ACL for Udp traffic from any to any, applied on bundle interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv4 ACL with Udp any any
            - Attach IPv4 ACL to bundle sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type UDP

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc16']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        stream = ['uut1_UDP_bunsub']
        ApData.verify_Bundle_TC(self, acl=ApData.aclname, sequance_no=seq, TX_frame=0, addr_family=ApData.addr_family,
                                dir=ApData.dir, location=loc, clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_UDP_bunsub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_UDP_bunsub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.bundle_members_location[0],
                                                   ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc16']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.ls
class TestIPV6DenyTcpPhyIngCompress(AclBaseAp):

    def test_deny_ace_compress_level_3(self):
        """
        TCP (IPV6) deny Acl on ingress direction to Phy Interface.

        This test will verify ACL for tcp traffic from any to any, applied on phy interface in ingress direction compress_level = 3

        Test Procedure:
            - Config IPv6 ACL with tcp.
            - Attach IPv6 ACL to phy interface on ingress direction
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type tcp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        #####################################################Attaching to the interface #################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc53']
        AclBaseAp._get_tcs_data(ApData)
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames']
        ##
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc53']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIPV6DenyTcpPhyEgrCompress(AclBaseAp):

    def test_deny_ace_compress_level_3(self):
        """
        TCP (IPV6) deny Acl on  egress direction to Phy Interface.

        This test will verify Ipv6 ACL for tcp traffic from any to any, applied on phy interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv6 ACL with tcp.
            - Attach IPv6 ACL to phy interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type tcp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        #####################################################Attaching to the interface #################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc54']
        AclBaseAp._get_tcs_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames']
        ##
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc54']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIPV6DenyUdpPhyIngCompress(AclBaseAp):

    def test_deny_ace_compress_level_3(self):
        """
        UDP (IPV6) deny Acl on  ingress direction to Phy Interface.

        This test will verify Ipv6 ACL for udp traffic from any to any, applied on phy interface in ingress direction.

        Test Procedure:
            - Config IPv6 ACL with udp.
            - Attach IPv6 ACL to phy interface on ingress direction
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type udp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        #####################################################Attaching to the interface #################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc55']
        AclBaseAp._get_tcs_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames']
        ##
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc55']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIPV6DenyUdpPhyEgrCompress(AclBaseAp):

    def test_deny_ace_compress_level_3(self):
        """
        UDP (IPV6) deny Acl on  egress direction to Phy Interface.

        This test will verify Ipv6 ACL for udp traffic from any to any, applied on phy interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv6 ACL with udp.
            - Attach IPv6 ACL to phy interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type udp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        #####################################################Attaching to the interface #################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc56']
        AclBaseAp._get_tcs_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames']
        ##
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc56']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIpv6TcpDenyPhySubIngressCompress(AclBaseAp):

    def test_ipv6_tcp_deny_physub_ingress_compress_level_3(self):
        """
        TCP (IPV6) deny Acl on  ingress direction to Phy Sub Interface.

        This test will verify Ipv6 ACL for tcp traffic from any to any, applied on phy sub interface in ingress direction compress_level = 3.

        Test Procedure:
            - Config IPv6 ACL with tcp.
            - Attach IPv6 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type tcp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc57']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={seq: [matches, rx_count]},
                                         location=[ApData.hw_loc])
    def teardown_class(self):

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc57']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIpv6TcpDenyPhySubEgressCompress(AclBaseAp):

    def test_ipv6_tcp_deny_physub_egress_compress_level_3(self):
        """
        TCP (IPV6) deny Acl on  egress direction to Phy Sub Interface.

        This test will verify Ipv6 ACL for tcp traffic from any to any, applied on phy sub interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv6 ACL with tcp.
            - Attach IPv6 ACL to phy sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type tcp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc58']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Physub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={seq: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc58']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIpv6UdpDenyPhySubIngressCompress(AclBaseAp):

    def test_ipv6_udp_deny_phy_sub_ingress_compress_level_3(self):
        """
        UDP (IPV6) deny Acl on  ingress direction to Phy Sub Interface.

        This test will verify Ipv6 ACL for udp traffic from any to any, applied on phy sub interface in ingress direction compress_level = 3.

        Test Procedure:
            - Config IPv6 ACL with udp.
            - Attach IPv6 ACL to phy sub interface on ingress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type udp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """

        # UDP traffic with sub interface  ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc59']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc59']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIpv6UdpDenyPhySubEgressCompress(AclBaseAp):

    def test_ipv6_udp_deny_phy_sub_egress_compress_level_3(self):
        """
        UDP (IPV6) deny Acl on  egress direction to Phy Sub Interface.

        This test will verify Ipv6 ACL for udp traffic from any to any, applied on phy sub interface in egress direction compress_level = 3.

        Test Procedure:
            - Config IPv6 ACL with udp.
            - Attach IPv6 ACL to phy sub interface on egress direction compress_level = 3
            - Send traffic
            - Verify hardware hit count

        Configurations:
            - Config ACL with protocol type udp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        # UDP traffic with sub interface  egress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc60']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc60']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIPv6PortIngressAclHostAddressNotEqualtoWithCompress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='neq',
            port_number=1023,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_port_obj_group_any_any"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6PortIngressAclHostAddressNotEqualto_compress(self):
        """
        IPV6 Port Object-Group parameter Port number and Not Equal to option type set on Ingress Phy intf

        This testcase Verify Object group with Port type configure on ACE , Accept traffic when packets hit which Not Equale to specified port number with compress level 3

        Test Procedures:
            - Config Port Object group with Not equal to for specified port no
            - Config Ipv4 ACL with ACE that contains Port object group
            - Attach ACL to Phy interface on Ingress direction with compress level 3
            - Send traffic with different port number
            - Verify hardware hit for packets which Not equal to for specified port no on expected ACE
            - clean config

        Configurations:
            - create object group port type
            - config ACL
            - Attach ACL to interface

        Verifications:
            - Verify hardware hit count on interface

        Triggers:
            - None


        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,compress_level=3, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        Apply acl to Phy Sub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6PortObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_port_obj_group_any_any"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        import pdb
        pdb.set_trace()
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count, extra=False),
                                                                AclBaseAp.tolerance_value(tcp_count, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count, extra=False),
                                                                AclBaseAp.tolerance_value(udp_count, extra=True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,compress_level=3, mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port',
            port_condition='neq',
            port_number=1023,
            mode="unconfig")


@pytest.mark.ls
class Test_ipv4_multiple_aces_with_Process_Restart_on_ingress_egress_with_compress(AclBaseAp):

    @pytest.mark.parametrize('process',
                             ["pfilter_ma", "pfilter_ea", "ipv4_acl_mgr", "ipv6_acl_daemon", "obj_mgr", "sysdb_mc",
                              "ifmgr", "netio"])
    def test_verify_multiple_aces_on_ipv4_with_Process_Restart_compress_level3(self, process):

        """
        Process Restart on Multiple v4 Aces.

        This case will Create Multiple Ipv4 aces which are Attached to phy Interface of Ingress and Egress direction and their is Addition
        of Ace to an existing ACL and traffic is passed to hit the traffic match count and triggers are started and the same
        procedure for the traffic is verified.

        Test Procedure:
            - Config Multiple IPv4 ACL which has tcp,udp,ospf
            - Attach ACL to Phy interface on Ingress direction compress_level=3
            - Add the Ace to the existing ACL
            - Send traffic
            - Verify packet for the added ace which has hit count.
            - Process to be Restarted is triggered
            - Verification of Respawn count is checked.
            - The same Traffic is passed to verify the hit counters.

        Configurations:
            - Acl with tcp,udp,ospf .

        Verifications:
            - Verifying the traffic hit count and no traffic loss.

        Triggers:
            - Process Restart.


        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc6', 'Tc8']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf,compress_level=3, mode="config")
        ##############################################Adding the aces############################################################

        test_case_name = ApData.acl_data['test_args']['apply_intf']
        for i in list1:
            acl_data = test_case_name[i]
            aclname = acl_data['aclname']
            aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(aclname_data, ApData.acl_uut, aclname)
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_Ospf_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc], add_ace=True)

        ###################################################Traffic verification on Ingress #####################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc8']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_Ospf_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['peer1_In_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc], add_ace=True)

        ####################################################################################################################################

        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        device = ApData.UUT1
        process1 = Process(device=device, mode=ApData.mode)
        aclname_data = ApData.acl_data['test_args']['apply_intf']['Tc6']
        intfl = aclname_data['intf_list']
        link = ApData.zap.get_link(intfl)
        intf = ApData.UUT1.get_local(link).name
        ApData.hw_loc = ApData.zap.get_node_name(device_objs=ApData.acl_uut, interface=intf)
        # #
        nodes = AclBaseAp.get_process_location(ApData.acl_data['test_args'], process)
        locations = list()
        for node in nodes:
            if node == 'rp':
                locations.append(ApData.active_rp)
            elif node == 'lc':
                locations.append(ApData.hw_loc)
        for location in locations:
            log.banner('Restart the process %s on the location %s' % (
                process, location))

        try:
            process_obj = process1.Restart(process1, process, location=location)
            process_obj.launch()
            process_obj.checker()
        except Exception as exception_error:
            log.error(exception_error)
        #
        #########################################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_Ospf_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        rx_count = ApData.stream_stats['uut1_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc], add_ace=True)

        ###################################################Traffic verification on Ingress #####################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc8']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_Ospf_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                           matches=CyDiff.Range(
                                                               AclBaseAp.tolerance_value(matches, extra=False),
                                                               AclBaseAp.tolerance_value(matches, extra=True))))

        rx_count = ApData.stream_stats['peer1_In_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
            ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                         location=[ApData.hw_loc], add_ace=True)

    #####################################################################################################################################################

    def teardown_class(self):
        list1 = ['Tc6', 'Tc8']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf,compress_level=3, mode="unconfig")


@pytest.mark.ls
class TestIPv6NetworkIngressAclHostAddressCompress(AclBaseAp):

    def setup_class(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclHostAddress_Compress_Level_1(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf

        This test-case verifies Object group with Network type , ACE uses object group and allow to match host.

        Test Procedure:
            - Config Ipv6 Network Object group with Host Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction   compress_level=1
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        import pdb
        pdb.set_trace()
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        #AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


    def test_verify_IPv6NetworkIngressAclHostAddress_Compress_Level_3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf

        This test-case verifies Object group with Network type , ACE uses object group and allow to match host.

        Test Procedure:
            - Config Ipv6 Network Object group with Host Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction   compress_level=3
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.ls
class TestIPv6NetworkIngressAclNetworkAddressCompress(AclBaseAp):
    def setup_class(self):
        """
        IPV6 Network Object-Group parameter Network Address type set on Ingress Phy intf
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclNetworkAddress_compress_level_3(self):
        """
        IPV6 Network Object-Group parameter Network Address type set on Ingress Phy intf

        This test-case verifies Object group with Network type , ACE uses object group and allow to match host fallin to network address specified.

        Test Procedure:
            - Config Ipv6 Network Object group with network Address parameter
            - Config Ipv6 ACL with ACE that contains object group
            - Attach ACL to Phy interface on Ingress direction compress_level=3
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACl
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,compress_level=3, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, compress_level=3,mode="unconfig")

        """
        ACL applying in Phy Sub         
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,compress_level=3, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[0]['sequence_number'],
                                           matches=str(tcp_count)))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                           sequence_number=seq[1]['sequence_number'],
                                           matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={seq[0]['sequence_number']: [tcp_count, rx_count1],
                                                  seq[1]['sequence_number']: [udp_count, rx_count2]},
                                         location=[ApData.hw_loc], add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf,compress_level=3, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


####### END OF LS
# pass
@pytest.mark.Feature('CompressedACL')
class TestIpv4NetworkIngressAclNetworkAddressCompresslevel3(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL
        
        Apply acl to an Ingress interface with compress and verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.20.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='120.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkIngressAclNetworkAddressCompresslevel3(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Ingress Phy intf with Compress Level 3
        
        This testcase Verify Object group with network type  and enabling Hybrid ACL with compression level 3 on Ingress direction
        
        Test Procedures:
            - Config Ipv4 Network Object group with Network Address parameter 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on expected ACE 
            - clean config 
        
        
        Configurations: 
            - create object group with network type
            - config ACL 
            - Attach ACL to interface and enable compress level 3 
            
        Verifications: 
            - Verify hardware hit count on interface 

        Triggers:
            - None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """

        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        ACL config on phy
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_PhySub']['Tx Frames'])
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.20.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='120.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.Feature('CompressedACL')
class TestIpv4NetworkEgressAclNetworkAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL
        
        Apply acl to an Egress interface with compressand verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkEgressAclNetworkAddressCompressLevel3(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Egress Phy intf with Compress Level 3
        
        This testcase Verify Object group with network type  and enabling Hybrid ACL with compression level 3 on Egress direction
        
        Test Procedures:
            - Config Ipv4 Network Object group with Network Address parameter 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Egress direction with compress level 3
            - Send traffic
            - Verify hardware hit count on expected ACE 
            - clean config 
        
        
        Configurations: 
            - create object group with network type
            - config ACL 
            - Attach ACL to interface and enable compress level 3 
            
        Verifications: 
            - Verify hardware hit count on interface 

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_Prec_1_stream', 'uut1_TCPstream2_PSH_Flag', 'uut1_TCP_TTL10', 'uut1_TCP_DSCP_AF22',
                  'uut1_TCPstream1','uut1_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_stream_total = int(
                ApData.stream_stats['uut1_Prec_1_stream']['Tx Frames']) + int(
                ApData.stream_stats['uut1_TCPstream2_PSH_Flag']['Tx Frames']) + int(
                ApData.stream_stats['uut1_TCP_TTL10']['Tx Frames']) + int(
                ApData.stream_stats['uut1_TCP_DSCP_AF22']['Tx Frames']) + int(
                ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_stream_total = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])

        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_stream_total,extra = False),AclBaseAp.tolerance_value(tcp_stream_total,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_stream_total,extra = False),AclBaseAp.tolerance_value(udp_stream_total,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            

        rx_tcp_stream_total = int(
                ApData.stream_stats['uut1_Prec_1_stream']['Rx Frames']) + int(
                ApData.stream_stats['uut1_TCPstream2_PSH_Flag']['Rx Frames']) + int(
                ApData.stream_stats['uut1_TCP_TTL10']['Rx Frames']) + int(
                ApData.stream_stats['uut1_TCP_DSCP_AF22']['Rx Frames']) + int(
                ApData.stream_stats['uut1_TCPstream1']['Rx Frames'])
        rx_udp_stream_total = int(ApData.stream_stats['uut1_UDPstream1']['Rx Frames'])
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_stream_total,rx_tcp_stream_total],seq[1]['sequence_number']:[udp_stream_total,rx_udp_stream_total]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


#####################################################################################
@pytest.mark.Feature('CompressedACL')
class TestIpv4NetworkPhySubEgressAclNetworkAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL
        
        Apply acl to an Egress interface with compressand verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkPhySubEgressAclNetworkAddressCompressLevel3(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Egress PhySub intf with Compress Level 3
        
        This test-case verifies Object group and hybrid acl compression level at 3 enable on interface

        Test Procedure:
            - Config Ipv4 Network Object group with Network Address parameter 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to PhySub interface on Egress direction with compress level 3 
            - Send traffic  
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_stream_total = int(ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames'])
        udp_stream_total = int(ApData.stream_stats['uut1_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=str(tcp_stream_total)))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=str(udp_stream_total)))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_stream_total,rx_count1],seq[1]['sequence_number']:[udp_stream_total,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")

@pytest.mark.Feature('CompressedACL')
class TestIPv6NetworkIngressAclHostAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclHostAddressCompressLevel3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf with Compress Level 3
        
        This test-case verifies Object group and hybrid acl compression level at 3 enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to PhySub interface on Ingress direction with compress level 3 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.Feature('CompressedACL')
class TestIPv6NetworkEgressAclHostAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        Apply acl to an Egress interface with compress and verify the tx and rx from traffic stream.
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkEgressAclHostAddressCompressLevel3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Egress Phy intf with Compress Level 3
        
        This test-case verifies Object group and hybrid acl compression level at 3 enable on interface 

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Egress direction with compress level 3 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupEgressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Phy', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


#############################################################################################################
@pytest.mark.Feature('CompressedACL')
class TestIPv6NetworkPhySubEgressAclHostAddressCompressLevel3(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkPhySubEgressAclHostAddressCompressLevel3(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Egress PhySub intf with Compress Level3
                
        This test-case verifies Object group and hybrid acl compression level at 3  enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to PhySub interface on Egress direction with compress level 3 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupEgressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Physub', 'uut1_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Physub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=str(tcp_count)))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.Feature('ObjectGroups')
class TestIPv6NetworkIngressAclHostAddress(AclBaseAp):

    def setup_class(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf 
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclHostAddress(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf
        
        This test-case verifies Object group with Network type , ACE uses object group and allow to match host.

        Test Procedure:
            - Config Ipv6 Network Object group with Host Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction  
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=str(tcp_count)))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=str(tcp_count)))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=str(udp_count)))
        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")


@pytest.mark.Feature('ObjectGroups')
class TestIPv6NetworkIngressAclNetworkAddress(AclBaseAp):
    def setup_class(self):
        """
        IPV6 Network Object-Group parameter Network Address type set on Ingress Phy intf 
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        """
        Apply object group to ACE 
        """

        aclname = "ipv6_permit_tcp_obj_group_any_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclNetworkAddress(self):
        """
        IPV6 Network Object-Group parameter Network Address type set on Ingress Phy intf 
        
        This test-case verifies Object group with Network type , ACE uses object group and allow to match host fallin to network address specified.

        Test Procedure:
            - Config Ipv6 Network Object group with network Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=str(tcp_count)))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        ACL applying in Phy Sub         
        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[0]['sequence_number'],
                                               matches=str(tcp_count)))
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq[1]['sequence_number'],
                                               matches=str(udp_count)))

        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address='120:1:1::/64',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")


##########################################################################################################################################################
@pytest.mark.sf
class Test_IPV4_SUB_PREC_DSCP_TTL(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["peer1_In_TCP_SUB_FLAG 63", "peer1_In_ICMP_SUB_timestamp_reply 67",
                              "peer1_In_ICMP_SUB_echo_reply 66",
                              "peer1_In_UDP_SUB_dscp_ttl 65"])
    def test_ipv4_sub_prec_dscp_ttl(self, stream):
        
        """
        Multiple IPv4 Aces which has TTL,DSCP Values,ICMP Type or ICMP code on Ingress PHY SUB-Interface.
        
        This case has Multiple Ipv4 deny aces of  TTL,DSCP Values,ICMP Type or ICMP code which are Attached
        to Phy-Sub of Ingress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has TTL,DSCP and ICMP Type
            - Attach ACL to Phy-Sub interface on Ingress direction          
            - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - ACL with TTL,DSCP Values,ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None     
        
        """
        
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_ipv4_sub_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv4_sub_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        stream_run=['peer1_In_TCP_SUB_FLAG','peer1_In_ICMP_SUB_timestamp_reply','peer1_In_ICMP_SUB_echo_reply','peer1_In_UDP_SUB_dscp_ttl']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_run)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        stream_name = []
        stream_name.append(stream_start)

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=aclname, sequence_number=seq, matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """
            
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        list1 = ['Tc_ipv4_sub_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.asr
class TestIPV6PRECDSCPTTL(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut1_IPV6_TCP_Phy peer1_In_IPV6_TCP_Phy 1 6",
                              "uut1_IPV6_UDP_Phy peer1_In_IPV6_UDP_Phy 2 7",
                              "uut1_IPV6_ICMP_echoreply peer1_In_IPV6_ICMP_echoreply 4 9",
                              "uut1_IPV6_ICMP_time_exceed peer1_In_IPV6_ICMP_timeexceed 3 8"
                                 , "uut1_IPV6_ICMP_dest_unreach peer1_In_IPV6_ICMP_dest_unreach 5 10",
                              "uut1_IPV6_ICMP_Phy peer1_In_IPV6_ICMP_Phy 6 11"])
    def test_ipv6_prec_dscp_ttl(self, stream):
       
        """
        Multiple Ipv6 Aces which has TTL,DSCP,Precedence Values,ICMP Type or ICMP code on Ingress and Egress PHY Interface.
        
        This case has Multiple Ipv6 deny Aces of TTL,DSCP,Precedence Values,ICMP Type or ICMP code which are Attached
        to Phy Interface of Ingress and Egress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv6 ACL which has TTL,DSCP,Precedence Values,ICMP Type or ICMP code
            - Attach ACL to Phy interface on Ingress and Egress direction
            - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - ACL with TTL,DSCP,Precedence Values,ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None   
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[2]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        stream_name = []
        stream_name.append(stream_start)
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        rx_count1 = int(ApData.stream_stats[stream_start]['Rx Frames'])
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[3]
        stream_start = sample[1]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        stream_name = []
        stream_name.append(stream_start)

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,
                                               sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        rx_count1 = int(ApData.stream_stats[stream_start]['Rx Frames'])
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
    def teardown_class(self):
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.fix3
class TestIPV4EGRESSPRECDSCPTTL(AclBaseAp):

    def test_ipv4_egress_prec_dscp_ttl(self):
        """
        Multiple Ipv4 Aces which has DSCP,Precedence Values,ICMP Type or ICMP code on Egress PHY Interface.
        
        This testcase has Multiple Ipv4 deny aces of DSCP,Precedence Values,ICMP Type or ICMP code which are Attached
        to Phy Interface of Egress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,Precedence Values,ICMP Type or ICMP code
            - Attach ACL to Phy Interface on Egress direction
            - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - ACL with DSCP,Precedence Values,ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """

        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_dscp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_TCP_DSCP_AF22']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []

        for i in range(0, len(stream_start)):
            seq = int(aclname_data[1]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

        ############################################################################################
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_UDP_Prec', 'uut1_UDP_DSCP']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[3]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


        #####################################################################################################################################
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_ICMPstream1', 'uut1_ICMP_echoreply', 'uut1_ICMP_redirect']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []

        for i in range(0, len(stream_start)):
            seq = int(aclname_data[7]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            try:
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

            except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
    def teardown_class(self):
        list1 = ['Tc_dscp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fail
class TestIPV4PERSTATISTICSINGRESSPRECDSCPTTL(AclBaseAp):

    def test_ipv4_per_statistics_ingress_prec_dscp_ttl(self):
        """
        Per-Interface Statistics of Ipv4 Aces which has DSCP,Precedence Values,ICMP Type or ICMP code.
        
        This case is Per-Interface statistics which has Multiple Ipv4 deny aces of TTL,DSCP Values,ICMP Type or
        ICMP code which are Attached Phy interface of Egress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has TTL,DSCP and ICMP Type
            - Attach ACL to Phy Interface on Egress direction based upon Interface Statistics.
            - Send traffic and  Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - ACL with DSCP,Precedence Values,ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=ApData.intf, location=ApData.hw_loc)

        stream_start = ['peer1_In_TCP_Prec', 'peer1_In_TCP_Dscp', 'peer1_In_TCP_TTL', 'peer1_In_TCP_FLAG',
                        'peer1_In_TCP_Prec_TTL', 'peer1_In_TCP_flag_prec']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

        ############################################################################################
        #####################################################################################################################################
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=ApData.intf, location=ApData.hw_loc)

        stream_start = ['peer1_In_ICMP_echoreply', 'peer1_In_ICMP_redirect', 'peer1_In_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[10]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.sf
class TestIPV4PRECDSCPTTLONIGMP(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut1_IGMP_v3_report peer1_In_IGMP_v3_report 29 66",
                              "uut1_IGMP_v2_Memb peer1_In_IGMP_v2_report 30 67"])
    def test_ipv4_prec_dscp_ttl_on_IGMP(self, stream):
        """
        Multiple Ipv4 Aces which has IGMP Type  on Ingress PHY Interface.
        
        This testcase will verify Multiple Ipv4 deny aces of IGMP Type which are Attached to Phy Interface of Egress 
        and Ingress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has IGMP Type 
            - Attach ACL to Phy Interface on Egress and Ingress direction
            - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - ACL with IGMP Type.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_dscp_igmp', 'Tc_prec_igmp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp_igmp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[2]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None, expected=0)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])

        verifier_obj = []

        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec_igmp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[3]
        stream_start = sample[1]
        AclBaseAp.traffic_verifier(ApData, stream_name=None, expected=0)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
    def teardown_class(self):
        list1 = ['Tc_dscp_igmp', 'Tc_prec_igmp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
##################################################################################################################################################################
@pytest.mark.custom
class TestIPV4INGRESSPRECDSCPTTL(AclBaseAp):

    def test_ipv4_ingress_prec_dscp_ttl(self):
        """
        Multiple Ipv4 Aces which has DSCP,Precedence Values,ICMP Type or ICMP code on Ingress PHY Interface.
        
        This testcase will verify Multiple Ipv4 deny aces with DSCP,Precedence Values,ICMP Type or ICMP code which are Attached
        to Phy Interface of Ingress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,Precedence Values,ICMP Type or ICMP code
            - Attach ACL to Phy Interface on Ingress direction
            - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - ACL with DSCP, Precedence, ICMP type and ICMP codes.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer1_In_TCP_Prec', 'peer1_In_TCP_Dscp', 'peer1_In_TCP_TTL', 'peer1_In_TCP_FLAG',
                        'peer1_In_TCP_Prec_TTL', 'peer1_In_TCP_flag_prec']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []

        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

        #####################################################################################################################################
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer1_In_ICMP_echoreply', 'peer1_In_ICMP_redirect', 'peer1_In_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []

        for i in range(0, len(stream_start)):
            seq = int(aclname_data[10]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.nc
class TestIPV6EGRESSPRECDSCPTTL(AclBaseAp):

    def test_ipv6_egress_prec_dscp_ttl(self):
        """
        Multiple Ipv6 Aces which has ICMP Type or ICMP code on  Egress PHY Interface. 
        
        This has Multiple Ipv6 deny aces like ICMP Type or ICMP code which are Attached
        to Phy Interface of Egress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv6 ACL which has ICMP Type or ICMP code
            - Attach ACL to Phy Interface on Egress direction           
            - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - Acl with ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_ipv6_dscp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

            ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_IPV6_ICMP_time_exceed', 'uut1_IPV6_ICMP_echoreply', 'uut1_IPV6_ICMP_dest_unreach',
                        'uut1_IPV6_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[2]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            stream_name = []
            stream_name.append(stream_start[i])
            verifier_obj=[]
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['Tc_ipv6_dscp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.fix4
class TestIPV6INGRESSPRECDSCPTTL(AclBaseAp):

    def test_ipv6_ingress_prec_dscp_ttl(self):
        """
        Multiple Ipv6 Aces which has ICMP Type or ICMP code on  Ingress PHY Interface.
        
        This has Multiple Ipv6 deny aces like ICMP Type or ICMP code which are Attached
        to Phy Interface of Ingress Direction and traffic is passed based upon the aces to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv6 ACL which has ICMP Type or ICMP code
            - Attach ACL to Phy Interface on Ingress direction
            - Send traffic 
            - Verify packet for the aces which has hit count and see their is no traffic loss.  

        Configurations:
            - Acl with ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None 
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer1_In_IPV6_ICMP_timeexceed', 'peer1_In_IPV6_ICMP_echoreply',
                        'peer1_In_IPV6_ICMP_dest_unreach']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[2]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            stream_name = []
            stream_name.append(stream_start[i])

            verifier_obj=[]
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix4
class TestIPV4PRECDSCPTTL(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut1_Prec_1_stream peer1_In_TCP_Prec 10 50",
                              "uut1_TCP_DSCP_AF22 peer1_In_TCP_Dscp 11 51", "uut1_Prec_1_stream peer1_In_TCP_TTL 10 52",
                              "uut1_TCPstream2_PSH_Flag peer1_In_TCP_FLAG 13 53",
                              "uut1_TCPstream2_PSH_Flag peer1_In_TCP_Prec_TTL 13 54",
                              "uut1_TCP_DSCP_AF22 peer1_In_TCP_flag_prec 11 55", 
                              "uut1_UDP_DSCP peer1_In_ICMP_Phy 18 65",
                              "uut1_TCP_DSCP_AF22 peer1_In_ICMP_redirect 11 64",
                              "uut1_UDP_Prec peer1_In_UDP_dscp_ttl 17 58",
                              "uut1_UDP_Prec peer1_In_TCP_flag_prec 17 55",
                              "uut1_Ospf_Phy peer1_In_Ospf_Phy 23 60", "uut1_ospf_dscp peer1_In_TCP_Prec_TTL 24 54",
                              "uut1_ICMP_echoreply peer1_In_ICMP_Phy 32 65",
                              "uut1_ICMPstream1 peer1_In_TCP_TTL 31 52",
                              "uut1_ICMP_redirect peer1_In_OSPF_dscp_ttl 33 61",
                              "uut1_ICMP_redirect peer1_In_ICMP_redirect 33 64",
                              "uut1_ICMP_echoreply peer1_In_ICMP_echoreply 32 63",
                              "uut1_ICMPstream1 peer1_In_ICMP_Phy 31 65"])
    def test_ipv4_prec_dscp_ttl(self, stream):
        """
        Multiple Ipv4 Aces which has DSCP,Precedence Values,ICMP Type or ICMP code on Ingress and Egress PHY Interface.
        
        This has Multiple Ipv4 deny aces like DSCP,Precedence Values,ICMP Type or ICMP code which are Attached
        to Phy Interface of Ingress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,Precedence Values,ICMP Type or ICMP code
            - Attach ACL to Phy Interface on Ingress and Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with  DSCP,Precedence Values,ICMP Type or ICMP code.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None 
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_dscp', 'Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[2]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None, expected=0)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[3]
        stream_start = sample[1]
        AclBaseAp.traffic_verifier(ApData, stream_name=None, expected=0)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

    def teardown_class(self):
        list1 = ['Tc_dscp', 'Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.fix4
class TestIPV4PACKETLENGTHPRECDSCPTTL(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut1_TCP_dscp_ttl_packlen peer1_In_TCP_dscp_pack_ttl 16 56",
                              "uut1_ospf_prec_ttl_packlen peer1_In_OSPF_dscp_ttl_pack 28 62",
                              "uut1_UDP_dscp_ttl_packlen peer1_In_UDP_dscp_pack_ttl 22 59"])
    def test_ipv4_packet_length_prec_dscp_ttl(self, stream):
        """
        Multiple Ipv4 Aces which has Packet-Length ,DSCP ,TTL Values on Ingress and Egress PHY Interface.
        
        This has Multiple Ipv4 deny aces like Packet-Length ,DSCP ,TTL Values which are Attached
        to Phy Interface of Ingress and Egress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has Packet-Length ,DSCP ,TTL Values
            - Attach ACL to Phy Interface on Ingress and Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with Packet-Length ,DSCP ,TTL Values .           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None 
            
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_dscp_packet_length', 'Tc_prec_packet_length']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp_packet_length']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        sample = []
        sample = stream.split(" ")
        seq = sample[2]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec_packet_length']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        sample = []
        sample = stream.split(" ")
        seq = sample[3]
        stream_start = sample[1]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['Tc_dscp_packet_length', 'Tc_prec_packet_length']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.fix4
class TestIPV4SUBPACKETLENGTHPRECDSCPTTL(AclBaseAp):
    @pytest.mark.parametrize('stream', ["peer1_In_TCP_SUB_dscp_ttl_pack 64"])
    def test_ipv4_sub_packet_length_prec_dscp_ttl(self, stream):
        """
        Multiple Ipv4 Aces which has Packet-Length ,DSCP ,TTL Values on PHY SUB-Ingress and PHY SUB-Egress Interface.
         
        This has Multiple Ipv4 deny aces like Packet-Length ,DSCP ,TTL Values which are Attached
        to Phy Sub Interface of Ingress and Egress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has Packet-Length ,DSCP ,TTL Values
            - Attach ACL to Phy-Sub Interface on Ingress and Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with Packet-Length ,DSCP ,TTL Values.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_ipv4_sub_prec_packet_length']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv4_sub_prec_packet_length']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['Tc_ipv4_sub_prec_packet_length']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ###########################################################################bvi#############################################################################
@pytest.mark.nc
class TestBVIIPV4SUBPRECDSCPTTLEGRESSINTERFACE(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut2_tcp_bvi_prec 10", "uut2_tcp_bvi_ttl_prec 11",
                              "uut2_udp_bvi_dscp 12", "uut2_ospf_bvi_ttl 13", "uut2_icmp_bvi_time_exec 14",
                              "uut2_icmp_bvi_echo_reply 15"])
    def test_bvi_ipv4_sub_prec_dscp_ttl_egress_interface(self, stream):
        """
        Multiple Ipv4 Aces which has DSCP,PRECEDENCE,TTL Values on BVI SUB-Interface for Egress.
        
        This has Multiple Ipv4 deny aces like DSCP,PRECEDENCE Values,ICMP TYPE which are Attached
        to BVI Interface of Egress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,PRECEDENCE Values,ICMP TYPE
            - Attach ACL to BVI Interface on  Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with DSCP,PRECEDENCE,TTL Values .           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
        
        """

        #
        #####################################################Attaching to the interface #################################################
        list1 = ['bvi']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['bvi']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")

@pytest.mark.fix4
class TestBVIIPV4SUBPRECDSCPTTLINGRESSINTERFACE(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["peer2_In_tcp_bvi 21", "peer2_In_udp_bvi 22",
                              "peer2_In_ospf_bvi 23", "peer2_In_icmp_bvi 24", "peer2_In_icmp_bvi_redirect 25"])
    def test_bvi_ipv4_sub_prec_dscp_ttl_ingress_interface(self, stream):
        """
        Multiple Ipv4 Aces which has DSCP,PRECEDENCE,Values and ICMP Type on BVI SUB-Interface for Ingress.
        
        This has Multiple Ipv4 deny aces like DSCP,PRECEDENCE Values,ICMP TYPE which are Attached
        to BVI Interface of Ingress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,PRECEDENCE Values,ICMP TYPE
            - Attach ACL to BVI Interface on Ingress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with DSCP,PRECEDENCE,Values and ICMP Type.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['bvi_In']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_In']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        list1 = ['bvi_In']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")
@pytest.mark.fix4
class TestBVIIPV6SUBPRECDSCPTTLEGRESSINTERFACE(AclBaseAp):
    @pytest.mark.parametrize('stream',
                             ["uut2_ipv6_tcp_bvi 1", "uut2_ipv6_udp_bvi 2",
                              "uut2_ipv6_icmp_dest_unreach 5", "uut2_ipv6_icmp_echo_reply 4",
                              "uut2_ipv6_icmp_time_exceed 3"])
    def test_bvi_ipv6_sub_prec_dscp_ttl_egress_interface(self, stream):
        """
        Multiple Ipv6 Aces which has DSCP,PRECEDENCE Values,ICMP TYPE on BVI SUB-Interface for Egress.
        
        This has Multiple Ipv6 deny aces like DSCP,PRECEDENCE Values,ICMP TYPE which are Attached
        to BVI Interface of Egress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv6 ACL which has DSCP,PRECEDENCE Values,ICMP TYPE
            - Attach ACL to BVI Interface on Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with DSCP,PRECEDENCE Values,ICMP TYPE.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['bvi_Ipv6_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")

        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['bvi_Ipv6_Egress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        # aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        sample = []
        sample = stream.split(" ")
        seq = sample[1]
        stream_start = sample[0]
        AclBaseAp.traffic_verifier(ApData, stream_name=None)
        matches = int(ApData.stream_stats[stream_start]['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats[stream_start]['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['bvi_Ipv6_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")


@pytest.mark.fix4
class TestGREIPV4EGRESS(AclBaseAp):
    
    def test_gre_ipv4_egress(self):
        """
        Multiple Ipv4 Aces which has been been attached to GRE Interface for Egress.
        
        This has Multiple Ipv4 deny aces like DSCP,ICMP TYPE which are Attached
        to GRE Interface of Egress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,ICMP TYPE
            - Attach ACL to GRE Interface on Egress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with DSCP,ICMP TYPE.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['GRE_Egress']
        
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['GRE_Egress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
       
        stream_start = ['uut2_UDP_GRE', 'uut2_icmp_time_exceed_GRE']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['GRE_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")

@pytest.mark.fix4
class TestGREIPV4INGRESS(AclBaseAp):
    
    def test_gre_ipv4_ingress(self):
        """
        Multiple Ipv4 Aces which has been been attached to GRE Interface for Ingress.
        
        This has Multiple Ipv4 deny aces like DSCP,ICMP TYPE which are Attached
        to GRE Interface of Ingress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,ICMP TYPE
            - Attach ACL to GRE Interface on Ingress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with DSCP,ICMP TYPE.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        ##
        #####################################################Attaching to the interface #################################################
        list1 = ['GRE_Ingress']
        
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")
        
        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['GRE_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
       
        stream_start = ['peer2_In_udp_GRE', 'peer2_In_icmp_exec_GRE']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
       
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['GRE_Ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")
@pytest.mark.fix4
class TestGREIPV4EGRESSINGRESS(AclBaseAp):
    
    def test_gre_ipv4_egress_ingress(self):
        """
        Multiple Ipv4 Aces which has been been attached to GRE Interface for Ingress and Egress.
        
        This has Multiple Ipv4 deny aces like DSCP,ICMP TYPE which are Attached to GRE Interface
        of Egress and Ingress Direction and traffic is passed with single stream  to hit the match count.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has DSCP,ICMP TYPE
            - Attach ACL to GRE Interface on Egress nad Ingress direction
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss.  

        Configurations:
            - Acl with DSCP,ICMP TYPE.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        ##
        #####################################################Attaching to the interface #################################################
        list1 = ['GRE_Egress','GRE_Ingress']
        
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=interface_name, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['GRE_Egress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
       
        stream_start = ['uut2_UDP_GRE', 'uut2_icmp_time_exceed_GRE']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

        ###############################################################Ingress###############################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['GRE_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data=ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
       
        stream_start = ['peer2_In_udp_GRE', 'peer2_In_icmp_exec_GRE']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
       
        matches = []
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['GRE_Egress','GRE_Ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            interface_name = ApData.acl_data['test_args']['apply_intf'][i]['interface_name']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=interface_name, mode="unconfig")                                              
@pytest.mark.check
class TestAtomicreplacementipv4(AclBaseAp):

    def test_atomic_replacement_ipv4(self):

        """
        Atomic Replacement of Ipv4  ACL on Ingress and Egress PHY Interface.
        
        This test will have multiple Ipv4 aces with the acl names attached to Ingress and Egress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.
        
        Test Procedure:
            1. This Test will do Create the Multiple IPv4  Aces on Ingress and Egress.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.
        
        Configurations:
            - Acl with dscp,precedence,ttl values.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_atomic', 'Tc_replace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_atomic']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_TCP_DSCP_AF22', 'uut1_Ospf_Phy', 'uut1_ICMP_redirect']
        seqn = ['11','23','33']
        
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_replace']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
   
        stream_start = ['peer1_In_TCP_Prec', 'peer1_In_TCP_flag_prec', 'peer1_In_UDP_Phy', 'peer1_In_Ospf_Phy','peer1_In_ICMP_echoreply','peer1_In_ICMP_Phy']
        seqn = ['50','55','57','60','63','65']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

                                                              
        ####################################################For Atomic replacement###########################################################
        list1 = ['Tc_dscp', 'Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        
        stream_start = ['uut1_TCP_DSCP_AF22',  'uut1_Ospf_Phy', 'uut1_ICMP_redirect']
        seqn = ['11','23','33']

        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        
        stream_start = ['peer1_In_TCP_Prec', 'peer1_In_TCP_flag_prec', 'peer1_In_UDP_Phy', 'peer1_In_Ospf_Phy','peer1_In_ICMP_echoreply','peer1_In_ICMP_Phy']
        seqn = ['50','55','57','60','63','65']
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

        
        

    def teardown_class(self):
        list1 = ['Tc_dscp', 'Tc_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")                                            

@pytest.mark.asr
class TestAtomicreplacementipv6(AclBaseAp):

    def test_atomic_replacement_ipv6(self):

        """
        Atomic Replacement of Ipv6  ACL on Ingress and Egress PHY Interface.
        
        This test will have multiple Ipv6 aces with the acl names attached to Ingress and Egress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.
        
        Test Procedure:
            1. This Test will do Create the Multiple IPv6  Aces on Ingress and Egress.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.
        
        Configurations:
            - Acl with Precedence,dscp.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_atomicipv6', 'Tc_replaceipv6']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_atomicipv6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)      
        stream_start = ['uut1_IPV6_ICMP_time_exceed', 'uut1_IPV6_ICMP_dest_unreach']
        seqn = ['3','5']
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_replaceipv6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream_start = ['peer1_In_IPV6_ICMP_timeexceed', 'peer1_In_IPV6_ICMP_Phy']
        seqn = ['8','11']
       
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)   
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

                                                              
        ####################################################For Atomic replacement###########################################################
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_dscp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_IPV6_ICMP_time_exceed', 'uut1_IPV6_ICMP_dest_unreach']
        seqn = ['3','5']
        
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

        ################################Ingress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_ipv6_prec']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        
        stream_start = ['peer1_In_IPV6_ICMP_timeexceed', 'peer1_In_IPV6_ICMP_Phy']
        seqn = ['8','11']
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        for seq in range(0, len(seqn)):
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[seq]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[seq],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[seq]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[seq]:[matches,rx_count1]},location=[ApData.hw_loc])

        
        

    def teardown_class(self):
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")                                             

@pytest.mark.fix4
class TestIPV4EGRESSL2INT(AclBaseAp):

    def test_ipv4_egress_l2_int(self):
        
        """
        IPv4 ACL on L2 Interface for Egress .
        
        This test will have multiple Ipv4 aces with the acl names attached L2 interface of Egress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.
        
        Test Procedure:
            1. This Test will do Create the Multiple IPv4  Aces on L2 interface for Egress direction.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.
        
        Configurations:
            - Acl with tcp,udp host to host.
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
        
        """
        #
        #####################################################Attaching to the interface #################################################
        
        list1 = ['L2_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

            ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['L2_Egress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut2_UDP_L2intf', 'uut2_icmp_dest_L2intf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        matches = []
        for i in range(0, len(stream_start)):
                seq = int(aclname_data[0]['sequence_number'])
                seq = int(seq) + i
                matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

                verifier_obj = []
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
                """
                Verify hardware hit count on interface 
                """  
                rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['L2_Egress']
        for i in list1:
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix4
class TestIPV4INGRESSL2INT(AclBaseAp):

    def test_ipv4_ingress_l2_int(self):
        """
        IPv4 ACL on L2 Interface for Ingress .
        
        This test will have multiple Ipv4 aces with the acl names attached L2 interface of Ingress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.
        
        Test Procedure:
            1. This Test will do Create the Multiple IPv4  Aces on L2 interface for Ingress direction.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.
        
        Configurations:
            - Acl with tcp,udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        
        list1 = ['L2_Ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

            ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['L2_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer2_In_udp_L2intf', 'peer2_In_icmp_echo_reply_L2intf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        matches = []

        for i in range(0, len(stream_start)):
                seq = int(aclname_data[0]['sequence_number'])
                seq = int(seq) + i
                matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

                verifier_obj = []
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
                """
                Verify hardware hit count on interface 
                """  
                rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['L2_Ingress']
        for i in list1:
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix4
class TestIPV6EGRESSL2INT(AclBaseAp):

    def test_ipv6_egress_l2_int(self):
        """
        IPv6 ACL on L2 Interface for Egress .
        
        This test will have multiple Ipv6 aces with the acl names attached L2 interface of Egress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.
        
        Test Procedure:
            1. This Test will do Create the Multiple IPv6  Aces on L2 interface for Egress direction.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.
        
        Configurations:
            - Acl with tcp,udp host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        
        list1 = ['L2_Ipv6_Egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

            ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['L2_Ipv6_Egress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut2_ipv6_tcp_L2intf', 'uut2_ipv6_icmp_echo_L2intf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
       
        matches = []
        for i in range(0, len(stream_start)):
                seq = int(aclname_data[0]['sequence_number'])
                seq = int(seq) + i
                matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

                verifier_obj = []
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
                """
                Verify hardware hit count on interface 
                """  
                rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['L2_Ipv6_Egress']
        for i in list1:
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix4
class TestIPV6INGRESSL2INT(AclBaseAp):

    def test_ipv6_ingress_l2_int(self):
        """
        IPv6 ACL on L2 Interface for Ingress .
        
        This test will have multiple Ipv6 aces with the acl names attached L2 interface of Ingress direction the traffic
        is passed to hit the counter value and after that change the acl names and pass the same stream to hit the counter value.
        
        Test Procedure:
            1. This Test will do Create the Multiple IPv6  Aces on L2 interface for Ingress direction.
            2. Verified by passing the Particular Stream of IPv4 ACE to match the hit counter for an ACE.
            3. And is Replaced with the different Ipv4 ACL name.
            4. Verify the same traffic stream passed for matching the hit count.
        
        Configurations:
            - Acl with tcp,udp,gre host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #
        #####################################################Attaching to the interface #################################################
        
        list1 = ['L2_Ipv6_Ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

            ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['L2_Ipv6_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['peer2_In_Ipv6_TCP_L2intf', 'peer2_In_Ipv6_echo_reply_L2intf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        matches = []
        for i in range(0, len(stream_start)):
                seq = int(aclname_data[0]['sequence_number'])
                seq = int(seq) + i
                matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

                verifier_obj = []
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=str(seq),
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
                """
                Verify hardware hit count on interface 
                """  
                rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        list1 = ['L2_Ipv6_Ingress']
        for i in list1:
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.asr
class TestDualStackonIngressEgressipv4ipv6L2interface(AclBaseAp):

    def test_dual_stack_on_ingress_egress_on_ipv4_ipv6_on_L2interface(self):

        """
        Dual stack ACL on L2 Interface for Egress and Ingress .
        
        This test will have Ipv4 acl and Ipv6 acl attached L2 interface of Ingress and Egress direction the traffic
        is passed to hit the counter value .
        
        Test Procedure:
            1. This Test will do Create Ipv4 acl and IPv6 acl on L2 interface for Ingress and Egress direction.
            2. Verified by passing the Particular Stream of IPv4 and IPv6 ACE to match the hit counter for an ACE.
        
        Configurations:
            - Acl with tcp,usp,ospf,gre host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
            
        """
        #####################################Attaching to the interface #################################################
        list1 = ['L2_Ipv6_Ingress', 'L2_Ipv6_Egress', 'L2_Ingress', 'L2_Egress']
       
        for tc in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][tc]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=ApData.hw_loc)
        stream_start = ['peer2_In_Ipv6_TCP_L2intf', 'uut2_ipv6_tcp_L2intf', 'peer2_In_udp_L2intf', 'uut2_icmp_dest_L2intf']
        seqn = ['20', '10', '20', '11']
        
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)

        for lt in range(0,len(list1)):
                ApData.test_case = ApData.acl_data['test_args']['apply_intf'][list1[lt]]
                AclBaseAp._get_tcs_data(ApData)
                AclBaseAp._get_loc_int(ApData, ApData.intf)
                verifier_obj = []
                matches = ApData.stream_stats[stream_start[lt]]['Tx Frames']
                
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[lt],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                """
                Verify hardware hit count on interface 
                """  
                rx_count1 = ApData.stream_stats[stream_start[lt]]['Rx Frames']
                try:
                    ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[lt]:[matches,rx_count1]},location=[ApData.hw_loc])
                except Exception as e:
                    raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        list1 = ['L2_Ipv6_Ingress', 'L2_Ipv6_Egress', 'L2_Ingress', 'L2_Egress']
        for tc in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][tc]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.sf
class TestDualStackonIngressEgressipv4ipv6(AclBaseAp):

    def test_dual_stack_on_ingress_egress_on_ipv4_ipv6(self):

        """
        Dual stack Ipv4 and IPv6 ACL on Egress and Ingress PHY Interface.
        
        This test will have Ipv4 acl and Ipv6 acl attached to Phy interface of Ingress and Egress direction the traffic
        is passed to hit the counter value .
        
        Test Procedure:
            1. This Test will do Create Ipv4 acl and IPv6 acl to Phy interface for Ingress and Egress direction.
            2. Verified by passing the Particular Stream of IPv4 and IPv6 ACE to match the hit counter for an ACE.
        
        Configurations:
            - Acl with tcp,udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
        
        """
        #####################################Attaching to the interface #################################################
        list1 = ['Tc_ipv6_dscp', 'Tc_ipv6_prec', 'Tc_dscp', 'Tc_prec']
        
        for tc in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][tc]
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=ApData.hw_loc)
        stream_start = ['uut1_IPV6_TCP_Phy', 'peer1_In_IPV6_TCP_Phy', 'uut1_TCP_DSCP_AF22', 'peer1_In_TCP_Prec']
        seqn = ['1', '6', '11', '50']
        
        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
        
        for lt in range(0,len(list1)):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][list1[lt]]
            AclBaseAp._get_tcs_data(ApData)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[lt]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[lt],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[lt]]['Rx Frames']
            try:
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[lt]:[matches,rx_count1]},location=[ApData.hw_loc])
            except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        list1 = ['Tc_prec', 'Tc_dscp', 'Tc_ipv6_prec', 'Tc_ipv6_dscp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix4
class TestDualStackonIngressEgress(AclBaseAp):

    def test_dual_stack_on_ingress_egress(self):

        """
        Dual stack IPv4 ACL on Egress and Ingress PHY Interface.
        
        This test will have Ipv4 acl  attached to phy interface of Ingress and Egress direction the traffic
        is passed to hit the counter value .
        
        Test Procedure:
            1. This Test will do Create Ipv4 acl  to phy interface for Ingress and Egress direction.
            2. Verified by passing the Particular Stream of IPv4 and IPv6 ACE to match the hit counter for an ACE.
        
        Configurations:
            - Acl with tcp,udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None
        
        """
        #####################################Attaching to the interface #################################################
        list1 = ['Tc_dscp', 'Tc_prec']
        for tc in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][tc]
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

            ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=ApData.hw_loc)
        stream_start = [ 'uut1_TCP_DSCP_AF22', 'peer1_In_TCP_Prec']
        seqn = ['11', '50']

        ################
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        
       
        for lt in range(0,len(list1)):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][list1[lt]]
            AclBaseAp._get_tcs_data(ApData)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            verifier_obj = []
            matches = ApData.stream_stats[stream_start[lt]]['Tx Frames']
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seqn[lt],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[lt]]['Rx Frames']
            try:
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seqn[lt]:[matches,rx_count1]},location=[ApData.hw_loc])
            except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
    def teardown_class(self):
        list1 = ['Tc_prec','Tc_dscp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix4
class TestDualStackDenyPhyIng(AclBaseAp):                                                
   def test_dual_stack_deny_ing_ace(self):
    """
    TCP (IPV4 and IPV6) deny Acl on ingress direction to Phy Interface.
    
    This test will have Ipv4 and Ipv6 acl attached to phy interface in Ingress direction the traffic is passed to hit the counter value .
        
    Test Procedure:
        1. This Test will do Create Ipv4  and Ipv6 acl to phy interface in ingress direction.
        2. Verified by passing the Particular Stream of IPv4 and IPv6 ACE to match the hit counter for an ACE.
    
    Configurations:
        - Configuring Acl and Attaching to the interface.           
        
    Verifications:
        - Verifying the traffic hit count and there is no traffic loss.
       
    Triggers:
        - None
        
    """
    #####################################################Attaching to the interface #################################################
    list1 = ['tc42', 'tc53']
    for tc in list1:
        ApData.test_case = ApData.acl_data['test_args']['apply_intf'][tc]
        AclBaseAp._get_tcs_data(ApData)
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_Phy', 'peer1_In_IPV6_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        if 'tc42' in tc:
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        if 'tc53' in tc:
            matches = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """
        if 'tc42' in tc:
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        if 'tc53' in tc:
            rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


   def teardown_class(self):
        list1 = ['tc42', 'tc53']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.fail
class TestDualStackDenyPhyEgr(AclBaseAp):
   def test_dual_stack_deny_egr_ace(self):

    """
    TCP (IPV4 and IPV6) deny Acl on egress direction to Phy Interface.
    
    This test will have Ipv4 and Ipv6 acl attached to phy interface in Egress direction the traffic is passed to hit the counter value .
        
    Test Procedure:
        1. This Test will do Create Ipv4  and Ipv6 acl to phy interface in egress direction.
        2. Verified by passing the Particular Stream of IPv4 and IPv6 ACE to match the hit counter for an ACE.
    
    Configurations:
        - Configuring Acl and Attaching to the interface.           
        
    Verifications:
        - Verifying the traffic hit count and there is no traffic loss.
       
    Triggers:
        - None
        
    """
    #####################################################Attaching to the interface #################################################
    list1 = ['tc43', 'tc54']
    for tc in list1:
        ApData.test_case = ApData.acl_data['test_args']['apply_intf'][tc]
        AclBaseAp._get_tcs_data(ApData)
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCPstream1', 'uut1_IPV6_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        if 'tc43' in tc:
            matches = ApData.stream_stats['uut1_TCPstream1']['Tx Frames']
            rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        if 'tc54' in tc:
            matches = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames']
            rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


   def teardown_class(self):
     list1 = ['tc43', 'tc54']
     for i in list1:
        ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
@pytest.mark.meta
class TestIpv4MetaACLIngress(AclBaseAp):
    def test_ipv4_MetaACLPhyIngress(self):
        """
        Ipv4 Meta ACL on Ingress Phy intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure:
            - Config 5 diff Ipv4 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
        
        Triggers:
            - None

        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            """
            attach meta ACL
            """
           
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhy_ingress']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv4_meta_acl_test1', 'ipv4_meta_acl_test2', 'ipv4_meta_acl_test3', 'ipv4_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy', 'peer1_In_Ospf_Phy', 'peer1_In_ICMP_echoreply']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        tx_data={'ipv4_meta_acl_test1':['peer1_In_TCP_Phy','10'],'ipv4_meta_acl_test2':['peer1_In_UDP_Phy','20'],'ipv4_meta_acl_test3':['peer1_In_ICMP_echoreply','30'],'ipv4_meta_acl_test4':['peer1_In_Ospf_Phy','40']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                    ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                    matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
                
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")

@pytest.mark.meta
class TestIpv4MetaACLPhySubIngress(AclBaseAp):
    def test_Ipv4MetaACLPhySubIngress(self):
        """
        Ipv4 Meta ACL on Ingress PhySub intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure:
            - Config 5 diff Ipv4 ACL 
            - Attach 4 ACL and 1 ACL as common to PhySub interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhySub_Ingress']

        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv4_meta_acl_test1', 'ipv4_meta_acl_test2', 'ipv4_meta_acl_test3', 'ipv4_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        
        tx_data={'ipv4_meta_acl_test1':['peer1_In_TCP_PhySub','10'],'ipv4_meta_acl_test2':['peer1_In_UDP_PhySub','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                    ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                    matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhySub_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.meta
class TestIpv4MetaACLBundlePhyIngress(AclBaseAp):
    def test_Ipv4MetaACLBundlePhyIngress(self):
        """
        Ipv4 Meta ACL on Ingress Bundle intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure:
            - Config 5 diff Ipv6 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to Bundle Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclBundlePhy_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf2, mode="config")

        loc=[]
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        acl_name = ['ipv4_meta_acl_test1', 'ipv4_meta_acl_test2', 'ipv4_meta_acl_test3', 'ipv4_meta_acl_test4']
        for aclname in acl_name:
            ApData.verify_Bundle_TC(self,acl=aclname,sequance_no=0,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)

        """
        Verify Traffic
        """
        stream = ['peer2_In_TCP_Bundle', 'peer2_In_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        
        """
        Verify hardware hit count on interface 
        """
        tx_data=dict()
        seq=0
        
        tx_data={'ipv4_meta_acl_test1':['peer2_In_TCP_Bundle','10'],'ipv4_meta_acl_test2':['peer2_In_UDP_Bundle','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                        ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=tx_data[aclname][1],
                        matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={tx_data[aclname][1]:[matches,rx_count1]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclBundlePhy_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf2, mode="unconfig")

@pytest.mark.meta
class TestIpv4MetaACLBundlePhySubIngress(AclBaseAp):
    def test_Ipv4MetaACLBundlePhySubIngress(self):
        """
        Ipv4 Meta ACL on Ingress Bundle Sub intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure:
            - Config 5 diff Ipv4 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to Bundle PhySub interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
        
        Triggers:
            - None

        """
        
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclBundlePhySub_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
                                            
        loc=[]
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        acl_name = ['ipv4_meta_acl_test1', 'ipv4_meta_acl_test2', 'ipv4_meta_acl_test3', 'ipv4_meta_acl_test4']
        for aclname in acl_name:
            ApData.verify_Bundle_TC(self,acl=aclname,sequance_no=0,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_BunSub', 'peer1_In_UDP_BunSub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        tx_data=dict()
        seq=0
        tx_data={'ipv4_meta_acl_test1':['peer1_In_TCP_BunSub','10'],'ipv4_meta_acl_test2':['peer1_In_UDP_BunSub','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                ApData.aclname = aclname
                verifier_obj = []
                verifier_obj.append(
                        ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=tx_data[aclname][1],
                        matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={tx_data[aclname][1]:[matches,rx_count1]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclBundlePhySub_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.meta
class TestIpv6MetaACLIngressPhy(AclBaseAp):
    def test_Ipv6MetaACLIngressPhy(self):
        """
        Ipv6 Meta ACL on Ingress Phy intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.
        
        Test Procedure:
            - Config 5 diff Ipv6 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface
             
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6MetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv6_meta_acl_test1', 'ipv6_meta_acl_test2', 'ipv6_meta_acl_test3', 'ipv6_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy', 'peer1_In_IPV6_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_data={'ipv6_meta_acl_test1':['peer1_In_IPV6_TCP_Phy','10'],'ipv6_meta_acl_test2':['peer1_In_IPV6_UDP_Phy','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                    ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                    matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        
        
        verifier_obj = []
                                                                      
        matches=ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames']
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name='ipv6_meta_acl_test1',sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")

@pytest.mark.meta
class TestIpv6MetaACLIngressPhySub(AclBaseAp):
    def test_Ipv6MetaACLIngressPhySub(self):
        """
        Ipv6 Meta ACL on Ingress PhySub intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure:
            - Config 5 diff Ipv6 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to PhySub interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6MetaAclPhySub_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv6_meta_acl_test1', 'ipv6_meta_acl_test2', 'ipv6_meta_acl_test3', 'ipv6_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub', 'peer1_In_IPV6_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_data={'ipv6_meta_acl_test1':['peer1_In_IPV6_TCP_PhySub','10'],'ipv6_meta_acl_test2':['peer1_In_IPV6_UDP_PhySub','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                    ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                    matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
    
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6MetaAclPhySub_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.meta
class TestIpv6MetaACLIngressBundle(AclBaseAp):
    def test_Ipv6MetaACLIngressBundle(self):
        """
        Ipv6 Meta ACL on Ingress Bundle intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure:
            - Config 5 diff Ipv6 ACL 
            - 4 Meta-interface ACL and 1 Meta-common ACL to Bundle Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface for specified ACL 
        
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6MetaAclBundlePhy_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf2, mode="config")

        """
        Clear acl counters 
        """        
        loc=[]
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        acl_name = ['ipv6_meta_acl_test1', 'ipv6_meta_acl_test2'] 
        for aclname in acl_name:
            ApData.verify_Bundle_TC(self,acl=aclname,sequance_no=0,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)

        """
        Verify Traffic
        """
        stream = ['peer2_In_IPV6_TCP_Bundle', 'peer2_In_IPV6_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_data=dict()
        seq=0
        tx_data={'ipv6_meta_acl_test1':['peer2_In_IPV6_TCP_Bundle','10'],'ipv6_meta_acl_test2':['peer2_In_IPV6_UDP_Bundle','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                    ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                    matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6MetaAclBundlePhy_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf2, mode="unconfig")

@pytest.mark.test
class TestIpv4ChangeOrderofMetaACLIngress(AclBaseAp):
    def test_Ipv4ChangeOrderofMetaACLIngress(self):
        """
        Change Order of Ipv4 Meta ACL on Ingress Phy intf
                
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedures:
            - Config 5 diff Ipv4 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 
            - Change order of ACL 
            - Send Traffic 
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv4_meta_acl_test1', 'ipv4_meta_acl_test2', 'ipv4_meta_acl_test3', 'ipv4_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy', 'peer1_In_Ospf_Phy', 'peer1_In_ICMP_echoreply']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        """
        Verify hardware hit count on interface 
        """
        seq=0
        tx_data={'ipv4_meta_acl_test1':['peer1_In_TCP_Phy','10'],'ipv4_meta_acl_test2':['peer1_In_UDP_Phy','20'],'ipv4_meta_acl_test3':['peer1_In_ICMP_echoreply','30'],'ipv4_meta_acl_test4':['peer1_In_Ospf_Phy','40']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        """
        Change order of Meta acl
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4ChangeOrderofMetaAclPhy']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv4_meta_acl_test1', 'ipv4_meta_acl_test2', 'ipv4_meta_acl_test3', 'ipv4_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_ICMP_echoreply', 'peer1_In_Ospf_Phy', 'peer1_In_UDP_Phy', 'peer1_In_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        """
        Verify hardware hit count on interface 
        """
        seq=0
        tx_data={'ipv4_meta_acl_test2':['peer1_In_TCP_Phy','10'],'ipv4_meta_acl_test2':['peer1_In_UDP_Phy','20'],'ipv4_meta_acl_test3':['peer1_In_ICMP_echoreply','30'],'ipv4_meta_acl_test4':['peer1_In_Ospf_Phy','40']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")
@pytest.mark.test
class TestIpv6ChangeOrderofMetaACLIngressPhy(AclBaseAp):
    def test_Ipv6ChangeOrderofMetaACLIngressPhy(self):
        """
        Change Order of Ipv6 Meta ACL on Ingress Phy intf
        
        This test-case verifies 5 level ACL Chaining (Meta ACL) , Meta-common-ACL group and Meta-Interface-ACL group ACL config on single interface at ingress direction.
        When traffic hits on interface Meta-common ACL is verified frist and then Meta-interface ACL in chaining fashion.

        Test Procedure :
            - Config 5 diff Ipv6 ACL 
            - Attach 4 Meta-interface ACL and 1 Meta-common ACL to Phy interface on Ingress direction 
            - Send traffic  
            - Verify hardware hit count on interface 
            - Change order of ACL 
            - Send Traffic 
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6MetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv6_meta_acl_test1', 'ipv6_meta_acl_test2', 'ipv6_meta_acl_test3', 'ipv6_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy', 'peer1_In_IPV6_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        seq=0
        tx_data={'ipv6_meta_acl_test1':['peer1_In_IPV6_TCP_Phy','10'],'ipv6_meta_acl_test2':['peer1_In_IPV6_UDP_Phy','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        """
        change order of ACL
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6ChangeOrderofMetaAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv6_meta_acl_test1', 'ipv6_meta_acl_test2', 'ipv6_meta_acl_test3', 'ipv6_meta_acl_test4']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        """
        Verify hardware hit count on interface 
        """
        seq=0
        tx_data={'ipv6_meta_acl_test2':['peer1_In_IPV6_TCP_Phy','10'],'ipv6_meta_acl_test2':['peer1_In_IPV6_UDP_Phy','20']}
        for aclname in tx_data.keys():
                matches= ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
                seq= tx_data[aclname][1]
                ApData.aclname = aclname
                verifier_obj=[]
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
                rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4MetaAclPhy_ingress']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="unconfig")

@pytest.mark.check
class TestIpv4FragmentACLIngressPhy(AclBaseAp):
    def test_Ipv4FragmentACLIngressPhy(self):
        """
        Fragments parameter set on ACE , Verify hardware hit count on Ingress side Phy intf

        This test-case verifies IPV4 ACL with Frament parameter set on ACE , when fragmented packet hit on ACL interface appropriate action take care. 

        Test Procedure:
            - Config Ipv4 ACL , set fragments parameter in ACE 
            - Attach Ipv4 ACL on Phy interface Ingress direction 
            - Send traffic with fragment packet 
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
        
        Triggers:
            - None

        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            """
            attach meta ACL
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentACLIngressPhy']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_fragment', 'peer1_In_UDP_fragment']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_count1 = ApData.stream_stats['peer1_In_TCP_fragment']['Tx Frames']
        tx_count2 = ApData.stream_stats['peer1_In_UDP_fragment']['Tx Frames']
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1,extra = False),AclBaseAp.tolerance_value(tx_count1,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1,extra = False),AclBaseAp.tolerance_value(tx_count1,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_fragment']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_fragment']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tx_count1,rx_count1],'20':[tx_count2,rx_count2]},location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentACLIngressPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")
@pytest.mark.check
class TestIpv4FragmentACLIngressPhySub(AclBaseAp):
    def test_Ipv4FragmentACLIngressPhySub(self):
        """
        Fragments parameter set on ACE , Verify hardware hit count on Ingress side PhySub intf

        This test-case verifies IPV4 ACL with Frament parameter set on ACE , when fragmented packet hit on ACL interface appropriate action take care. 

        Test Procedure:
            - Config Ipv4 ACL , set fragments parameter in ACE 
            - Attach Ipv4 ACL on PhySub interface Ingress direction 
            - Send traffic with fragment packet 
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentACLIngressPhySub']

        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_PhySub_fragment', 'peer1_In_UDP_PhySub_fragment']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        
        tx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub_fragment']['Tx Frames']
        tx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub_fragment']['Tx Frames']
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1,extra = False),AclBaseAp.tolerance_value(tx_count1,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1,extra = False),AclBaseAp.tolerance_value(tx_count1,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub_fragment']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub_fragment']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tx_count1,rx_count1],'20':[tx_count2,rx_count2]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentACLIngressPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
@pytest.mark.bug
class TestIpv4FragmentACLEgressPhy(AclBaseAp):
    def test_Ipv4FragmentACLEgressPhy(self):
        """
        Fragments parameter set on ACE , Verify hardware hit count on Egress side Phy intf

        This test-case verifies IPV4 ACL with Frament parameter set on ACE , when fragmented packet hit on ACL interface appropriate action take care. 

        Test Procedure:
            - Config Ipv4 ACL , set fragments parameter in ACE 
            - Attach Ipv4 ACL on Phy interface Egress direction 
            - Send traffic with fragment packet 
            - Verify hardware hit count on interface
        
        Configurations:
            - Config ACL
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
 
        Triggers:
            - None

        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            """
            attach meta ACL
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentACLEgressPhy']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['uut1_TCP_fragment', 'uut1_UDP_fragment']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_count1 = ApData.stream_stats['uut1_TCP_fragment']['Tx Frames']
        tx_count2 = ApData.stream_stats['uut1_UDP_fragment']['Tx Frames']
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1,extra = False),AclBaseAp.tolerance_value(tx_count1,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1,extra = False),AclBaseAp.tolerance_value(tx_count1,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_TCP_fragment']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_fragment']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tx_count1,rx_count1],'20':[tx_count2,rx_count2]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentACLEgressPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")
            #################################################################################################

@pytest.mark.reload
class TestIpv4DenyTcpPhyTrafficOnWrongInterface(AclBaseAp):
    def test_deny_wrong_interface_phy(self):

        """
        ACL on wrong interface (Physical)
                        
        This test will apply an acl to an interface and verify hit count on a wrong interface.
        
        Test Procedure:
            - Config IPv4 ACL to physical
            - Attach ACL to Phy interface on Ingress direction
            - Send traffic and Verify packet on a different stream.
            
        Configurations:
            - configuring Acl and Attaching to the interface.           
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """
        #####################################################Attaching to the interface #################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc41']
        AclBaseAp._get_tcs_data(ApData)
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        if 'matches' in ace_list:
            actual_match = ace_list.matches['access_list_name'][0][access_list_name]['matches']
            if actual_match == matches:
                raise CafyException.VerificationError('Failed Traffic verification for sf-sim')

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc41']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.checkfrag
class TestIpv4FragmentTrafficACLIngressPhy(AclBaseAp):
    def test_Ipv4FragmentTrafficACLIngressPhy(self):
        """
        Send Fragment traffic on ACL interface Ingress.

        TEACATS BUG : CSCvj51675 , CSCvj61896  Fragment
        This test-case verifies IPV4 ACL without Fragment parameter set on ACE , Send fragment traffic and verify hit cout

        Test Procedure:
            - Config Ipv4 ACL
            - Attach Ipv4 ACL on Phy interface Ingress direction
            - Send traffic with fragment packet
            - Verify hardware hit count on interface

        Configurations:
            - Config ACL
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            """
            attach meta ACL
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc42']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_fragment', 'peer1_In_UDP_fragment']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_count1 = ApData.stream_stats['peer1_In_TCP_fragment']['Tx Frames']
        tx_count2 = ApData.stream_stats['peer1_In_UDP_fragment']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number='10',
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1, extra=False),
                                                                AclBaseAp.tolerance_value(tx_count1, extra=True))))
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number='20',
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1, extra=False),
                                                                AclBaseAp.tolerance_value(tx_count1, extra=True))))
        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['peer1_In_TCP_fragment']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_fragment']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={'10': [tx_count1, rx_count1],'20': [tx_count2, rx_count2]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc42']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")


@pytest.mark.checkfrag
class TestIpv4FragmentTrafficACLEgressPhy(AclBaseAp):
    def test_Ipv4FragmentTrafficACLEgressPhy(self):
        """
        Send Fragment traffic on ACL interface Egress.

        TEACATS BUG : CSCvj51675 , CSCvj61896  Fragment

        This test-case verifies IPV4 ACL without Frament parameter set on ACE , Send fragment traffic and verify hit cout

        Test Procedure:
            - Config Ipv4 ACL 
            - Attach Ipv4 ACL on Phy interface Egress direction
            - Send traffic with fragment packet
            - Verify hardware hit count on interface

        Configurations:
            - Config ACL
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            """
            attach meta ACL
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentTrafficEgress']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['uut1_TCP_fragment', 'uut1_UDP_fragment']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tx_count1 = ApData.stream_stats['uut1_TCP_fragment']['Tx Frames']
        tx_count2 = ApData.stream_stats['uut1_UDP_fragment']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number='15',
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1, extra=False),
                                                                AclBaseAp.tolerance_value(tx_count1, extra=True))))

        verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number='20',
                                           matches=CyDiff.Range(AclBaseAp.tolerance_value(tx_count1, extra=False),
                                                                AclBaseAp.tolerance_value(tx_count1, extra=True))))
        """
        Verify hardware hit count on interface 
        """
        rx_count1 = ApData.stream_stats['uut1_TCP_fragment']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_fragment']['Rx Frames']

        ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                         traffic={'10': [tx_count1, rx_count1], '20': [tx_count2, rx_count2]},
                                         location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['FragmentTrafficEgress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")
        #################################################################################################
@pytest.mark.reload
class TestIpv4DenyTcpPhySubTrafficOnWrongInterface(AclBaseAp):
    def test_deny_wrong_interface_physub(self):

        """
        Verifying ACL on wrong interface (Physical sub).
                                
        This test will apply an acl to an interface and verify hit count on a wrong interface.
        
        Test Procedure:
            - Config IPv4 ACL
            - Attach ACL to Phy sub interface on Ingress direction
            - Send traffic and Verify packet on a different stream.
            
        Configurations:
            - configuring Acl and Attaching to the interface.           
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """
        #####################################################Attaching to the interface #################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        intf = intf2 + '.' + ApData.test_case['subint']
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        if 'matches' in ace_list:
            actual_match = ace_list.matches['access_list_name'][0][access_list_name]['matches']
            if actual_match == matches:
                raise CafyException.VerificationError('Failed Traffic verification for sf-sim')

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf, mode="unconfig")


@pytest.mark.reload
class TestIpv4DenyTcpMultipleIntf(AclBaseAp):
    def test_deny_multi_intf_ace(self):
        """
        Ipv4 TCP deny Acl on ingress direction to both Phy and Phy-sub Interface.
                                        
        This test will apply an acl to multiple interface and verify hit count by combining tarffic stats.
        
        Test Procedure:
            - Config IPv4 ACL
            - Attach ACL to Phy and Phy sub interface on Ingress direction
            - Send traffic and Verify hit count on combining hitcount.
            
        Configurations:
            - configuring Acl and Attaching to the interface.           
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """
        #####################################################Attaching to the interface #################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        intf = ApData.intf
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        
        AclBaseAp._get_loc_int(ApData, intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy', 'peer1_In_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        match1 = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        match2 = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']

        matches = int(match1) + int(match2)
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """
        rx_match1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_match2 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count1 = int(rx_match1) + int(rx_match2)
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.qos1 
class TestQosAclEgress(AclBaseAp):

    def test_qos_acl_egress(self):
        """
        Qos prioirty queing and verify the policymap with ACL in egress direction
        
        This test will apply service policy on egress interface
        
        Test Procedure:
            - Create calss map and policymap with ACL.
            - And apply service poilcy Phy egress interface.
            - Verify Policy map stats.
            
        Configurations:
            - configuring Class map and policy map.         
            - Apply the policy to egress interface.
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """ 
        log.banner("Apply class map and policy map on acl configured session")
        ApData.UUT1_interfaces = ApData.zap.get_interfaces(device=ApData.UUT1)
        ApData.ifmgr = IfMgr(device=ApData.UUT1, mode=ApData.mode)

        with pytest.allure.step("Apply class map and policy map"):
            device = ApData.UUT1
            ApData.qos_data = ApData.zap.get_feature_configuration('qos')
            ApData.classmap_inst = ClassMap(device=device, mode='cli')
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst)
            ApData.policymap_inst = PolicyMap(device=device, mode='cli')
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst)
            ApData.test_data = ApData.zap.get_feature_configuration("qos_args")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data)
            Helper.sleep(10, msg='applying policy map')

            link = ApData.zap.get_link("R1_R2_3")
            intf = ApData.UUT1.get_local(link).name
            ApData.policymap_inst.clear_qos_counters(["all"])
            stream = ['uut1_Prec_1_stream']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream)
            matches = ApData.stream_stats['uut1_Prec_1_stream']['Tx Frames']
            policy_map_expected_values = []
            policy = ApData.test_data['R1_R2_3.R1']['output']

            expected_values = PolicyMap.PolicerMapData(policy_name=policy, classmap_name=policy,
                                                       matched_pkts=matches)
            policy_map_expected_values.append(expected_values)

            ApData.policymap_inst.verify_show_policy_map_stats(
                policy_map_expected_values,
                interface=intf,
                direction='output', variation=0)

            
    def teardown_class(self):
                                            
        ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data, config_mode="delete")
        ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst,config_mode="delete")
        ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst,config_mode="delete")

@pytest.mark.qos1 
class TestQosAclIngress(AclBaseAp):

    def test_qos_acl_ingress(self):
        """
        Qos prioirty queing and verify the policymap with ACL in ingress direction
        
        This test will apply service policy on ingress interface
        
        Test Procedure:
            - Create calss map and policymap with ACL.
            - And apply service poilcy Phy ingress interface.
            - Verify Policy map stats.
            
        Configurations:
            - configuring Class map and policy map.         
            - Apply the policy to ingress interface.
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """ 
        log.banner("Apply class map and policy map on acl configured session")
        ApData.UUT1_interfaces = ApData.zap.get_interfaces(device=ApData.UUT1)
        ApData.ifmgr = IfMgr(device=ApData.UUT1, mode=ApData.mode)

        with pytest.allure.step("Apply class map and policy map"):
            device = ApData.UUT1
            ApData.qos_data = ApData.zap.get_feature_configuration('qos')
            ApData.classmap_inst = ClassMap(device=device, mode='cli')
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst)
            ApData.policymap_inst = PolicyMap(device=device, mode='cli')
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst)
            ApData.test_data = ApData.zap.get_feature_configuration("qos_args_input")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data)
            Helper.sleep(10, msg='applying policy map')

            link = ApData.zap.get_link("R1_R2_3")
            intf = ApData.UUT1.get_local(link).name
            ApData.policymap_inst.clear_qos_counters(["all"])
            stream = ['peer1_In_TCP_Prec']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream)
            matches = ApData.stream_stats['peer1_In_TCP_Prec']['Tx Frames']
            policy_map_expected_values = []
            policy = ApData.test_data['R1_R2_3.R1']['input']

            expected_values = PolicyMap.PolicerMapData(policy_name=policy, classmap_name=policy,
                                                       matched_pkts=matches)
            policy_map_expected_values.append(expected_values)

            ApData.policymap_inst.verify_show_policy_map_stats(
                policy_map_expected_values,
                interface=intf,
                direction='input', variation=0)

            
    def teardown_class(self):                                   
        ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data, config_mode="delete")
        ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst,config_mode="delete")
        ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst,config_mode="delete")
            
@pytest.mark.qos1            
class TestQosV6AclIngress(AclBaseAp):

    def test_qosv6_acl_ingress(self):
        """
        Qos prioirty queing and verify the policymap with ACL in ingress direction
        
        This test will apply service policy on ingress interface
        
        Test Procedure:
            - Create class map and policymap with ACL.
            - And apply service poilcy Phy ingress interface.
            - Verify Policy map stats.
            
        Configurations:
            - configuring Class map and policy map.         
            - Apply the policy to ingress interface.
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """ 
        log.banner("Apply class map and policy map on acl configured session")
        ApData.UUT1_interfaces = ApData.zap.get_interfaces(device=ApData.UUT1)
        ApData.ifmgr = IfMgr(device=ApData.UUT1, mode=ApData.mode)

        with pytest.allure.step("Apply class map and policy map"):
            device = ApData.UUT1
            ApData.qos_data = ApData.zap.get_feature_configuration('qosv6')
            ApData.classmap_inst = ClassMap(device=device, mode='cli')
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst)
            ApData.policymap_inst = PolicyMap(device=device, mode='cli')
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst)
            ApData.test_data = ApData.zap.get_feature_configuration("qos_args_input")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data)
            Helper.sleep(10, msg='applying policy map')

            link = ApData.zap.get_link("R1_R2_3")
            intf = ApData.UUT1.get_local(link).name
            ApData.policymap_inst.clear_qos_counters(["all"])
            stream = ['peer1_In_IPV6_TCP_Phy']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream)
            matches = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames']
            policy_map_expected_values = []
            policy = ApData.test_data['R1_R2_3.R1']['input']

            expected_values = PolicyMap.PolicerMapData(policy_name=policy, classmap_name=policy,
                                                       matched_pkts=matches)
            policy_map_expected_values.append(expected_values)

            ApData.policymap_inst.verify_show_policy_map_stats(
                policy_map_expected_values,
                interface=intf,
                direction='input', variation=0)


    def teardown_class(self):                                   
        ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data, config_mode="delete")
        ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst,config_mode="delete")
        ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst,config_mode="delete")

@pytest.mark.fix5
class TestTcamAclwithNetwflowUrpfQos(AclBaseAp):

    def test_tcam_acl(self):
        """
        Tcam exhaustion check by QOS,NETFLOW,URPF and ACL in ingress direction
        
        This test will apply service policy on ingress interface and configure netflow.
        
        Test Procedure:
            - Create calss map and policymap with ACL.
            - And apply service poilcy Phy ingress interface.
            - Configure netflow
            - Configure URPF
            - Configure ACL.
            
        Configurations:
            - configuring Class map and policy map.  
            - Configure netflow.       
            - Apply the policy to ingress interface.
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """ 
        ApData.UUT1_interfaces = ApData.zap.get_interfaces(device=ApData.UUT1)
        ApData.netflow_uut = Netflow(
            device=ApData.UUT1, name='netflow', mode="cli")
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc9']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name

        with pytest.allure.step("Test Netflow Urpf, QOS"):
            device = ApData.UUT1
            
            #QOS configurations
            ApData.qos_data = ApData.zap.get_feature_configuration('qos')
            ApData.classmap_inst = ClassMap(device=device, mode='cli')
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst)
            ApData.policymap_inst = PolicyMap(device=device, mode='cli')
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst)
            ApData.test_data = ApData.zap.get_feature_configuration("qos_args_input")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data)
            Helper.sleep(10, msg='applying policy map')
            
            #Netflow configurations
            ApData.netflow_uut.set_sampler_map(['netflow_sampler_map_1','netflow_sampler_map_2'], ['1000','2000'])
            ApData.netflow_uut.set_exporter_map(
                'netflow_exporter_map_1',
                'v9',
                '3.3.3.3',
                '43',
                'UDP',
                '2000')
            ApData.netflow_uut.set_monitor_map('netflow_monitor_map_2',['netflow_exporter_map_1'],'ipv4')
            ApData.netflow_uut.set_interface_netflow(
            ApData.intf,
            ApData.addr_family,
            'netflow_monitor_map_2',
            'netflow_sampler_map_1',
            ApData.dir)
            cfg = ApData.acl_uut.set_urpf_on_interface(interface=ApData.intf,mode="config",address_family="ipv4")
            
            

            # UDP traffic with physical interface ingress direction
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc9']
            AclBaseAp._get_tcs_data(ApData)
            ApData.intf = ApData.UUT1.get_local(ApData.link).name

            seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")
            ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
            ApData.log.info(ace_list)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir,
                                           interface=None, location=ApData.hw_loc)
            ApData.policymap_inst.clear_qos_counters(["all"])

            stream = ['peer1_In_UDP_Phy']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream)
            matches = ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames']
            verifier_obj=[]
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
            
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc9']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
                                            
        ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data, config_mode="delete")
        ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst,config_mode="delete")
        ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst,config_mode="delete")
        
        ApData.netflow_uut.set_interface_netflow(
        ApData.intf,
        ApData.addr_family,
        'netflow_monitor_map_2',
        'netflow_sampler_map_1',
        ApData.dir,mode='unconfig')
        ApData.netflow_uut.set_monitor_map('netflow_monitor_map_2',mode='unconfig')
        ApData.netflow_uut.set_sampler_map(['netflow_sampler_map_1','netflow_sampler_map_2'],mode='unconfig')
        ApData.netflow_uut.set_exporter_map('netflow_exporter_map_1', mode='unconfig')
        cfg = ApData.acl_uut.set_urpf_on_interface(interface=ApData.intf,mode="unconfig",address_family="ipv4")


@pytest.mark.sf
class TestIPV4DISABLEICMPREPLY(AclBaseAp):

    def setup_class(self):
        """
        This Test will do Create IPv4 Ace on R1.  
        """
        
        aclname= 'ipv4_icmp'
        addr_family='ipv4'
        seq_no='20'
        actions='deny'
        src={"any_host": True}
        dest={"any_host": True}
        protocol='icmp'
        acls_obj = ApData.acl_peer1.set_acl(access_list_name=aclname, address_family=ApData.addr_family)
        ace_obj = ApData.acl_peer1.set_ace(sequence_number=seq_no, action=actions, source=src,destination=dest, protocol_name=protocol,)
        ApData.acl_peer1.set_acl_ace(acls_obj, ace_obj, unit_test_mode=False)

    def test_ipv4_disable_icmp_reply(self):
        """
        Disabling ICMP Reply on Ipv4 Ace.
        
        This test case will have acl on R1 and R2 the traffic is passed to match on R1 and 
        from R2 ping check is done to R2 interface to disable the Icmp traffic.
        
        Test Procedure:
            - Config IPv4 Ace on R1 and R2 with icmp ace.  
            - Attach ACL of R1 to Phy Interface on egress direction
            - Similarly attach Acl of R2 to Ingress direction       
            - Send traffic for egress and Verify packet for the aces which has hit count and see their is no traffic loss. 
            - send the ping traffic from R2 to disable the icmp.

        Configurations:
            - Acl with tcp,icmp host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
           
        Triggers:
            - None 
        
        """
        #
        
        #####################################################Attaching to the interface #################################################
        list1 = ['disable_icmp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
                                                
        list1 = ['icmp_reply']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_peer1.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf_peer, mode="config")
        ###########################Ingress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['disable_icmp']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        
        stream_start = ['peer1_In_ICMP_echoreply']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []

        for i in range(0, len(stream_start)):
                seq = int(aclname_data[0]['sequence_number'])
                seq = int(seq) + i
                matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            
                verifier_obj = []
                verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
                """
                Verify hardware hit count on interface 
                """  
                rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
                ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

        #####################################################################################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['icmp_reply']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf_peer)
        ApData.acl_peer1.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        ping_check_intf = [ApData.interfaces['R1_T1_1.R1']]
        for interface in ping_check_intf:
            ApData.log.info('Ping for Icmp')
            ip_addr = interface.ipv4_address
            ApData.acl_peer1._push_configuration("ping " + ip_addr + "",mode="execute")
        
        for i in range(0, len(ping_check_intf)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))

            verifier_obj = []
            verifier_obj.append(
            ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
            matches=0))
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_peer1.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[0,rx_count1]},location=[ApData.hw_loc])        
 
    def teardown_class(self):
        list1 = ['disable_icmp']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        list2 = ['icmp_reply']
        for i in list2:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_peer1.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf_peer, mode="unconfig") 
@pytest.mark.custom
class TestSCALEIPV4EGRESSINGRESS(AclBaseAp):

    def setup_class(self):
        """
        This Test will create Multiple aces for Scale ACL.
        """
        
        #
        acl_data=ApData.acl_data['aclname_scale']['permit_egress_scale']
        prefix=None
        src='185.0.0.1'
        dest='195.0.0.1'
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        acl_data=ApData.acl_data['aclname_scale']['permit_ingress_scale']
        prefix=None
        src='195.0.0.1'
        dest='185.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv4_egress_ingress(self):
        """
        Scale IPv4 on Egress and Ingress PHY-SUB Interface.
        
        This case will create 2000 aces per acl on Egress and Ingress phy-sub Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has udp,ospf
            - Attach ACL Ingress and Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv4_egress','Scale_ipv4_ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_egress']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        

        matches=ApData.stream_stats[stream_start[0]]['Tx Frames']
        ApData.log.info(matches)                                                              

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,190,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
        ########################Ingress##########
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_ingress']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_scale_ospf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,1990,50):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
                

    def teardown_class(self):
        list1 = ['Scale_ipv4_egress','Scale_ipv4_ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)
@pytest.mark.custom
class TestSCALEIPV4EGRESS(AclBaseAp):

    def setup_class(self):
        """
        This Test will create Multiple aces for Scale ACL.
        """
        
        #
        acl_data=ApData.acl_data['aclname_scale']['permit_egress_scale']
        prefix=None
        src='185.0.0.1'
        dest='195.0.0.1'
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv4_egress(self):
        """
        Scale IPv4 on Egress PHY-SUB Interface.
        
        This case will create 200 aces per acl on Egress  phy-sub Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has ospf
            - Attach ACL  Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv4_egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_egress']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,190,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
    def teardown_class(self):
        list1 = ['Scale_ipv4_egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)
@pytest.mark.custom
class TestSCALEIPV4INGRESS(AclBaseAp):

    def setup_class(self):
        """
        1. This Test will create Multiple aces for Scale ACL.
        """
        
        #
        acl_data=ApData.acl_data['aclname_scale']['permit_ingress_scale']
        prefix=None
        src='195.0.0.1'
        dest='185.0.0.1'
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv4_ingress(self):
        """
        Scale IPv4 on Ingress PHY-SUB Interface.
        
        This case will create 2000 aces per acl on  Ingress phy-sub Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has udp
            - Attach ACL Ingress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv4_ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_ingress']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_scale_ospf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,1990,50):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')

    def teardown_class(self):
        list1 = ['Scale_ipv4_ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)

@pytest.mark.custom
class TestSCALEIPV6EGRESS(AclBaseAp):

    def setup_class(self):
        """
        1. This Test will create Multiple Ipv6 aces for Scale ACL.
        
        """
        
        #
        acl_data=ApData.acl_data['aclname_scale']['permit_egress_ipv6_scale']
        prefix=None
        src='180::3'
        dest='190::3'
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv6_egress(self):
        """
        Scale IPv6 on Egress  PHY-SUB Interface.
        
        This case will create 120 ipv6 aces per acl on Egress  phy-sub Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale ipv6 aces which has tcp
            - Attach ACL  Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with tcp host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv6_egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv6_egress']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['uut2_ipv6_scale_tcp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
                                                                   
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,110,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')

    def teardown_class(self):
        list1 = ['Scale_ipv6_egress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)
@pytest.mark.nc
class TestSCALEIPV6INGRESS(AclBaseAp):

    def setup_class(self):
        """
        Create IPv6 scale  ACL
        :return: None
        """
        
        #
        acl_data=ApData.acl_data['aclname_scale']['permit_ingress_ipv6_scale']
        prefix=None
        src='190::3'
        dest='180::3'
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv6_ingress(self):
        """
        Scale IPv6 on Ingress PHY-SUB Interface.
        
        This case will create 350 Ipv6 aces per acl on Ingress  phy-sub Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale Ipv6 aces which has udp
            - Attach ACL  Ingress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv6_ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv6_ingress']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_ipv6_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,330,20):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')

    def teardown_class(self):
        list1 = ['Scale_ipv6_ingress']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)
@pytest.mark.custom
class TestSCALEIPV4EGRESSNPU(AclBaseAp):

    def setup_class(self):
        """
        Create IPv4 and IPv6 scale  ACL
        
        """
       
        #
        acl_data=ApData.acl_data['aclname_scale']['permit_ingress_ipv6_scale']
        prefix=None
        src='190::3'
        dest='180::3'
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
            
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_scale']
        src='165.0.0.1'
        dest='175.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix) 
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_ipv4_scale']
        src='186.0.0.1'
        dest='196.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix) 
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_ipv4_scale']
        ###
        src='155.0.0.1'
        dest='154.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix) 
        ###
                
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_scale_vlan_22']
        src='144.0.0.1'
        dest='145.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        ##
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_scale_vlan_23']
        src='199.0.0.1'
        dest='198.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        ###
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_ipv4_scale_vlan_24']
        src='138.0.0.1'
        dest='139.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        ###
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_ipv4_scale_vlan_25']
        src='197.0.0.1'
        dest='187.0.0.1'
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        
       
    def test_scale_ipv4_egress_npu(self):
        """
        Scale IPv4 on Ingress and Egress per NPU on PHY-SUB Interface.
        
        This case will create 200 aces per NPU for IPv4 and IPv6 on each phy-sub Interface on Egress and Ingress and 
        traffic is passed to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces ipv4 and ipv6 per npu which has tcp,udp,ospf
            - Attach ACL  Egress and Ingress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with tcp,udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
        ###################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv6_ingress','Scale_ipv4_vlan19','Scale_ipv4_vlan20','Scale_ipv4_vlan21','Scale_ipv4_vlan22','Scale_ipv4_vlan23','Scale_ipv4_vlan24','Scale_ipv4_vlan25']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        list1 = ['Scale_ipv6_ingress','Scale_ipv4_vlan19','Scale_ipv4_vlan20','Scale_ipv4_vlan21','Scale_ipv4_vlan22','Scale_ipv4_vlan23','Scale_ipv4_vlan24','Scale_ipv4_vlan25']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
           
            AclBaseAp._get_tcs_data(ApData)
            aclname = ApData.aclname
            
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_scale_vlan20','uut2_scale_vlan24','uut2_scale_vlan22','uut2_scale_vlan19','peer2_In_scale_vlan21','peer2_In_scale_vlan25','peer2_In_scale_vlan23','peer2_In_ipv6_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)                                                       
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)
        list1 = ['Scale_ipv6_ingress','Scale_ipv4_vlan19','Scale_ipv4_vlan20','Scale_ipv4_vlan21','Scale_ipv4_vlan22','Scale_ipv4_vlan23','Scale_ipv4_vlan24','Scale_ipv4_vlan25']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            aclname = ApData.aclname
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            for i in range(3,150,10):
                if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
                else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
    def teardown_class(self):
        list1 = ['Scale_ipv6_ingress','Scale_ipv4_vlan19','Scale_ipv4_vlan20','Scale_ipv4_vlan21','Scale_ipv4_vlan22','Scale_ipv4_vlan23','Scale_ipv4_vlan24','Scale_ipv4_vlan25']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)

            
@pytest.mark.fonly
class TestScaleIPV4SingleInterface500ACEIngressEgress(AclBaseAp):

    def setup_class(self):
        """
        This Test will create Multiple aces for Scale ACL.
        """
        
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_egress_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_egress_scale_500_ace'][0]['dest']
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_ingress_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_ingress_scale_500_ace'][0]['dest']
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv4_single_interface_500_ace_ingress_egress_phy(self):
        """
        Scale IPv4 on Egress and Ingress PHY Interface.
        
        This case will create 500 aces per acl on Egress and Ingress phy Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has udp,ospf
            - Attach ACL Ingress and Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv4_egress_500_ace','Scale_ipv4_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        
        ########################Ingress##########
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_ingress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_scale_ospf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.active_rp )

        for i in range(3,490,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_egress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        

        matches=ApData.stream_stats[stream_start[0]]['Tx Frames']
        ApData.log.info(matches)         
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.active_rp )

        for i in range(3,490,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
                   

    def teardown_class(self):
        list1 = ['Scale_ipv4_egress_500_ace','Scale_ipv4_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)
            
@pytest.mark.fonly
class TestScaleIPV6SingleInterface500ACEIngressEgress(AclBaseAp):

    def setup_class(self):
        """
        This Test will create Multiple aces for Scale ACL.
        """
        
        #
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_ipv6_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_egress_ipv6_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_egress_ipv6_scale_500_ace'][0]['dest']
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_ipv6_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_ingress_ipv6_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_ingress_ipv6_scale_500_ace'][0]['dest']
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv6_single_interface_500_ace_ingress_egress_phy(self):
        """
        Scale IPv6 on Egress and Ingress PHY Interface.
        
        This case will create 500 aces per acl on Egress and Ingress phy Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has udp,ospf
            - Attach ACL Ingress and Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv6_egress_500_ace','Scale_ipv6_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ########################Ingress##########
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv6_ingress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_ipv6_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.active_rp )

        for i in range(3,480,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
           
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv6_egress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_ipv6_scale_tcp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        

        matches=ApData.stream_stats[stream_start[0]]['Tx Frames']
        ApData.log.info(matches)
                                                      

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.active_rp )

        for i in range(3,480,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
             

    def teardown_class(self):
        list1 = ['Scale_ipv6_egress_500_ace','Scale_ipv6_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)

@pytest.mark.donly
class TestScaleIPV4SingleInterface500ACEegressIngress(AclBaseAp):

    def setup_class(self):
        """
        This Test will create Multiple aces for Scale ACL.
        """
        
        #
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_egress_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_egress_scale_500_ace'][0]['dest']
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_ingress_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_ingress_scale_500_ace'][0]['dest']
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv4_single_interface_500_ace_egress_Ingress_phy(self):
        """
        Scale IPv4 on Egress and Ingress PHY Interface.
        
        This case will create 500 aces per acl on Egress and Ingress phy Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has udp,ospf
            - Attach ACL Ingress and Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv4_egress_500_ace','Scale_ipv4_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_egress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        

        matches=ApData.stream_stats[stream_start[0]]['Tx Frames']
        ApData.log.info(matches)       
        
        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc )

        for i in range(3,490,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
        
        ########################Ingress##########
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv4_ingress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_scale_ospf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,490,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
                

    def teardown_class(self):
        list1 = ['Scale_ipv4_egress_500_ace','Scale_ipv4_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)

@pytest.mark.donly
class TestScaleIPV6SingleInterface500ACEegressIngress(AclBaseAp):

    def setup_class(self):
        """
        This Test will create Multiple aces for Scale ACL.
        """
        
        acl_data=ApData.acl_data['aclname_scale']['deny_egress_ipv6_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_egress_ipv6_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_egress_ipv6_scale_500_ace'][0]['dest']
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
        acl_data=ApData.acl_data['aclname_scale']['deny_ingress_ipv6_scale_500_ace']
        prefix=None
        src=ApData.acl_data['aclname_scale']['deny_ingress_ipv6_scale_500_ace'][0]['src']
        dest=ApData.acl_data['aclname_scale']['deny_ingress_ipv6_scale_500_ace'][0]['dest']
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.configure_aclace_scale(acl_data, ApData.acl_uut,src,dest,prefix)
       
    def test_scale_ipv6_single_interface_500_ace_egress_Ingress_phy(self):
        """
        Scale IPv6 on Egress and Ingress PHY Interface.
        
        This case will create 500 aces per acl on Egress and Ingress phy Interface and traffic is passed
        to check the hit count and also we will check the TCAM entry by executing the command.
        
        Test Procedure:
            - Config Scale aces which has udp,ospf
            - Attach ACL Ingress and Egress interface Direction .
            - Send traffic and Verify packet by passing single stream for hit count and see their is no traffic loss. 
            - And check with the TCAM Entry utilization         

        Configurations:
            - Acl with udp,ospf host to host.           
            
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
            - Check the TCAM utilization
           
        Triggers:
            - None
            
        """
                
        #####################################################Attaching to the interface #################################################
        list1 = ['Scale_ipv6_egress_500_ace','Scale_ipv6_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        
        ################################Egress######################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv6_egress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream_start=['uut2_ipv6_scale_tcp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)
        

        matches=ApData.stream_stats[stream_start[0]]['Tx Frames']
        ApData.log.info(matches)                      

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc )

        for i in range(3,480,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
        
        ########################Ingress##########
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Scale_ipv6_ingress_500_ace']
       
        
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)
        
        stream_start=['peer2_In_ipv6_scale_udp']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start)

        cli_out_memb1 = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname,direction=ApData.dir,interface=None, location=ApData.hw_loc)

        for i in range(3,480,10):
            if (cli_out_memb1[i].matches) != '' :
                   ApData.log.info("The Hardware count packets are Hitting")
            else:
                   raise CafyException.VerificationError('Failed Traffic verification ')
                

    def teardown_class(self):
        list1 = ['Scale_ipv6_egress_500_ace','Scale_ipv6_ingress_500_ace']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            intf2 = ApData.UUT1.get_local(ApData.link).name
            ApData.intf = intf2 + '.' + ApData.test_case['subint']

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl_scale(ApData.acl_data, ApData.acl_uut)


@pytest.mark.spass      
class TestInterfaceFlap(AclBaseAp):

    def test_core_interface_flap(self):
        """
        Flap phy interface and verify tarffic match.
        
        This test will flap the physical interface and verify Acl for Tcp traffic on phy interface.
        
        Test Procedure:
            - Config Ipv4 acl
            - Applied Acl to Physical interface in ingress direction
            - Flap the interface twice.
            - Verified by passing the particular stream of ACE to match the hit counter.
                    
        Configurations:
            - Configuring Acl and Attaching to the interface.           
        
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
       
        Triggers:
            - None
        
        """
        # TCP traffic with physical interface ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc33']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
                                            
        with pytest.allure.step('Shut the interface'):
            ApData.uut1_ifmgr.shut(ApData.interfaces['R1_R2_3.R1'].name)
            Helper.sleep(20, msg='waiting for interface and protocols to go '
                                 'down')
        with pytest.allure.step('Verify the interface status'):
            ApData.uut1_ifmgr.verify_shut([ApData.interfaces['R1_R2_3.R1'].name])

        with pytest.allure.step('Unshut the interface'):
            ApData.uut1_ifmgr.noshut([ApData.interfaces['R1_R2_3.R1'].name])
            self.success = True
            Helper.sleep(20, msg='waiting for interface to come up')

        with pytest.allure.step('Verify the interface status'):
            ApData.uut1_ifmgr.verify_noshut([ApData.interfaces['R1_R2_3.R1'].name]) 
        

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_ICMP_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_ICMP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

                                                                      
    
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc33']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
@pytest.mark.spass
class TestSubInterfaceFlap(AclBaseAp):

    def test_core_sub_interface_flap(self):
        """
        Flap phy sub interface and verify packet hit count.
        
        This test will flap the physical sub interface and verify Acl for Tcp traffic on phy interface.
        
        Test Procedure:
            - Config Ipv4 acl
            - Applied Acl to Physical sub interface in ingress direction
            - Flap the interface twice.
            - Verified by passing the particular stream of ACE to match the hit counter.
                    
        Configurations:
            - Configuring Acl and Attaching to the interface.           
        
        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.
       
        Triggers:
            - None
        
        """

        # TCP traffic with sub interface  ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc21']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        with pytest.allure.step('Shut the interface'):
            ApData.uut1_ifmgr.shut(ApData.interfaces['R1_R2_3.R1'].name)
            Helper.sleep(20, msg='waiting for interface and protocols to go '
                                 'down')
        with pytest.allure.step('Verify the interface status'):
            ApData.uut1_ifmgr.verify_shut([ApData.interfaces['R1_R2_3.R1'].name])

        with pytest.allure.step('Unshut the interface'):
            ApData.uut1_ifmgr.noshut([ApData.interfaces['R1_R2_3.R1'].name])
            self.success = True
            Helper.sleep(20, msg='waiting for interface to come up')

        with pytest.allure.step('Verify the interface status'):
            ApData.uut1_ifmgr.verify_noshut([ApData.interfaces['R1_R2_3.R1'].name])


        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc21']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
@pytest.mark.spass
class Test_ipv4_multiple_aces_with_Process_Crash_on_ingress_egress(AclBaseAp):

    @pytest.mark.parametrize('process',
                             ["pfilter_ma", "pfilter_ea", "ipv4_acl_mgr", "ipv6_acl_daemon", "obj_mgr", "sysdb_mc",
                              "ifmgr", "netio"])
    def test_verify_multiple_aces_on_ipv4_with_Process_Crash(self, process):
        """
        Process crash on Multiple v4 Aces.
        
        This will Create Multiple Ipv4 aces which are Attached to Ingress and Egress Interface and their is Addition
        of Ace to an existing ACL and traffic is passed to hit the traffic match count and triggers are started and the same 
        procedure for the traffic is verified.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has tcp,udp,ospf
            - Attach ACL to Phy interface on Ingress direction
            - Add the Ace to the existing ACL
            - Send traffic 
            - Verify packet for the added ace which has hit count.
            - Process to be crashed is triggered 
            - Verification of Respawn count is checked.
            - The same Traffic is passed to verify the hit counters.            
        
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Process Crash.
        
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc6', 'Tc8']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        ##############################################Adding the aces############################################################

        test_case_name = ApData.acl_data['test_args']['apply_intf']
        for i in list1:
            acl_data = test_case_name[i]
            aclname = acl_data['aclname']
            aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(aclname_data, ApData.acl_uut, aclname)
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)
        ###################################################Traffic verification on Ingress #####################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc8']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)

        ####################################################################################################################################
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        device = ApData.UUT1
        process1 = Process(device=device, mode=ApData.mode)
        aclname_data = ApData.acl_data['test_args']['apply_intf']['Tc6']
        intfl = aclname_data['intf_list']
        link = ApData.zap.get_link(intfl)
        intf = ApData.UUT1.get_local(link).name
        ApData.hw_loc = ApData.zap.get_node_name(device_objs=ApData.acl_uut, interface=intf)
            # #
        nodes = AclBaseAp.get_process_location(ApData.acl_data['test_args'], process)
        locations = list()
        for node in nodes:
                if node == 'rp':
                    locations.append(ApData.active_rp)
                elif node == 'lc':
                    locations.append(ApData.hw_loc)
        for location in locations:
                log.banner('Crash the process %s on the location %s' % (
                    process, location))

        try:
            process_obj = process1.ProcessCrash(process1, process, location=location)
            process_obj.launch()
            process_obj.checker()
        except Exception as exception_error:
            log.error(exception_error)
        #
        #########################################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)

        ###################################################Traffic verification on Ingress #####################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc8']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)


    #####################################################################################################################################################

    def teardown_class(self):
        list1 = ['Tc6', 'Tc8']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")

@pytest.mark.nc
class TestIpv4IcmpPerLogging(AclBaseAp):

    def test_ipv4_icmp_logging(self):
        """
        Ipv4 ICMP permit Acl with logging applied on ingress direction.
        
        This test will verify ACL for icmp traffic from any to any with logging, applied on phy interface in ingress direction.
        
        Test Procedure:
            -  Config Ipv4 acl with Icmp with logging
            -  Acl is Applied to ingress Physical interface.
            -  Send traffic and Verify packet for the added ace which has hit count.  
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verify last 10 Acl log from show logging.
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - None
            
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc65']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        threshold = ApData.test_case['threshold']
        #
        ApData.acl_uut.set_acl_log_update(threshold=threshold,address_family=ApData.addr_family)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_ICMP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_ICMP_Phy']['Tx Frames']
        ApData.threshold = threshold


        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_ICMP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

 
        ApData.acl_uut.clear_acl_log_update(threshold=True, address_family=ApData.addr_family)

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc65']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

############################################################################################################################################################
@pytest.mark.sf
class TestIPV4EGRESSTTL(AclBaseAp):

    def test_ipv4_egress_ttl(self):
        """
        Multiple Ipv4 Aces which has TTL on Egress PHY Interface.

        This testcase has Multiple Ipv4 deny aces of TTL which are Attached
        to Phy Interface of Egress Direction and traffic is passed based upon the aces to hit the match count.

        Test Procedure:
        - Config Multiple IPv4 ACL which has TTL
        - Attach ACL to Phy Interface on Egress direction
        - Send traffic and Verify packet for the aces which has hit count and see their is no traffic loss. 

        Configurations:
        - ACL with TTL. 

        Verifications:
        - Verifying the traffic hit count and there is no traffic loss.

        Triggers:
        - None

        """

        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc_dscp_ttl']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        test_case_name = ApData.acl_data['test_args']['apply_intf']

        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc_dscp_ttl']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream_start = ['uut1_TCP_TTL10', 'uut1_TCP_Prec_TTL', 'uut1_TCP_DSCP_TTL', 'uut1_UDP_TTL',
                        'uut1_UDP_Prec_TTL','uut1_UDP_Dscp_TTL', 'uut1_ospf_ttl', 'uut1_ospf_prec_ttl', 'uut1_ospf_dscp_ttl']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []

        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])
            
        ############################################################################################
        

    def teardown_class(self):
        list1 = ['Tc_dscp_ttl']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
                                                
                                                
@pytest.mark.check                                              
class TestIpv4ImplicitDeny(AclBaseAp):

    def test_ipv4_implicit_deny(self):
        """
        Ipv4 implicit deny Icmp traffic on ingress direction to Physical Interface.
        
        This test will verify implicit deny for icmp on ingress direction
        
        Test Procedure:
            -  Config Ipv4 acl with Tcp
            -  Acl is Applied to ingress Physical interface.
            -  Send traffic and Verify packet for the added ace which has hit count.  
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - None
            
        """

        # TCP traffic with physical interface ingress direction
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc1']
        AclBaseAp._get_tcs_data(ApData)

        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir, interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_ICMP_Phy']

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_ICMP_Phy']['Tx Frames']
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_ICMP_Phy']['Rx Frames']
        
        if rx_count1 != 0:
           raise CafyException.VerificationError("Rx receiving traffic ,ICMP Implicit deny not working .")
        	
                
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc1']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")



@pytest.mark.fix5
class TestDenyIpv6RangePhy(AclBaseAp):
    def setup_class(self):
        """
        Create Acl by range protocol option.
        :return: None
        """
        test_case_name = ApData.acl_data['test_args']['apply_intf']
        aclname_data = test_case_name['tc64']
        aclname = aclname_data['aclname']
        aclname_data = ApData.acl_data['test_args']['ipv6_range'][aclname]
        addr_family = aclname_data[0]['address_family']
        seq_no = aclname_data[0]['sequence_number']
        actions = aclname_data[0]['action']
        src = aclname_data[0]['source']
        dest = aclname_data[0]['destination']
        protocol = aclname_data[0]['protocol_name']
        acls_obj = ApData.acl_uut.set_acl(access_list_name=aclname, address_family=ApData.addr_family)
        ace_obj = ApData.acl_uut.set_ace(sequence_number=seq_no, action=actions, source=src,
                                         destination=dest, protocol_name=protocol, )
        output = ApData.acl_uut.set_acl_ace(acls_obj, ace_obj, unit_test_mode=False)

    def test_deny_range_interface_phy(self):
        """
        Acl (protocol range) on ingress direction to Physical Interface.
        
        Test Procedure:
            - Config Acl with range.
            - Applied to  Physical interface in ingress direction.
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            None
            
        """
        #####################################################Attaching to the interface #################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc64']
        AclBaseAp._get_tcs_data(ApData)
        aclname_data = ApData.acl_data['test_args']['ipv6_range'][ApData.aclname]
        seq = aclname_data[0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames']
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc64']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


@pytest.mark.fix5
class TestDenyIpv6RangePhySub(AclBaseAp):
    def setup_class(self):
        """
        Create Acl and ace.
        :return: None
        """
        test_case_name = ApData.acl_data['test_args']['apply_intf']
        ApData.log.info("modifying and adding the aces")
        aclname_data = test_case_name['tc64']
        aclname = aclname_data['aclname']
        aclname_data = ApData.acl_data['test_args']['ipv6_range'][aclname]
        addr_family = aclname_data[0]['address_family']
        seq_no = aclname_data[0]['sequence_number']
        actions = aclname_data[0]['action']
        src = aclname_data[0]['source']
        dest = aclname_data[0]['destination']
        protocol = aclname_data[0]['protocol_name']
        acls_obj = ApData.acl_uut.set_acl(access_list_name=aclname, address_family=addr_family)
        ace_obj = ApData.acl_uut.set_ace(sequence_number=seq_no, action=actions, source=src,
                                         destination=dest, protocol_name=protocol, )
        output = ApData.acl_uut.set_acl_ace(acls_obj, ace_obj, unit_test_mode=False)

    def test_deny_range_interface_physub(self):
        """
        Acl (protocol range) on ingress direction to Physical Sub Interface.
        
        Test Procedure:
            - Config Acl with range.
            - Applied to  Physical sub interface in ingress direction.
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the phy sub interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            None
            
        """

        #####################################################Attaching to the interface #################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc64']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        intf = intf2 + '.' + ApData.test_case['subint']
        aclname_data = ApData.acl_data['test_args']['ipv6_range'][ApData.aclname]
        seq = aclname_data[0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames']
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc64']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf, mode="unconfig")                                                
                                            
@pytest.mark.sf
class TestIPv4NetworkIngressAddObjandChangeACECommitReplaceFile(AclBaseAp):
    def test_verify_IPv4NetworkIngressAddObjandChangeACECommitReplaceFile(self):
        """
        Commit Replace ipv4 acl operation to Add object group and Change ACE on Ingress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.
        
        Test Procedure:
            - config IPv4 ACL and Object-group
            - Attach IPv4 ACL to Phy interface on Ingress direction 
            - Save config in file 
            - Delete Object group and Change ACE
            - Single commit both new changes
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Commit Replace with old file 
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count 
        
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface  

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")
        """
        save the running config
        """
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        try:
            ApData.UUT1.default_handles['cli'].copy_current_config()
        except Exception as err:
            raise CafyException.LoadError()

        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['modify_addace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

        """
        commit replace to old config
        """
        try:
            # commit Replace
            #ApData.Config_dut.set_commit_replace_file()
            
            ApData.zap.mark_config(ApData.UUT1)
            ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)

        except Exception as err:
            raise CafyException.ConfigError()

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj = []
        
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            ApData.acl_data = ApData.zap.get_feature_configuration('acl')
@pytest.mark.nc
class TestIPv4NetworkIngressDelObjandDelACECommitRollback(AclBaseAp):
    def test_verify_IPv4NetworkIngressDelObjandDelACECommitRollback(self):
        """
        Commit Rollback ipv4 acl operation to Del object group and Del ACE on Ingress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.
        
        Test Procedure:
            - config IPv4 ACL and Object-group
            - Attach IPv4 ACL to Phy interface on Ingress direction 
            - Delete Object group and Delete ACE
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Rollback last 1 config
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count 
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface
            
        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        edit config
        """

        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, )

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])     
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)

        """
        Verify hardware hit count on interface 
        """
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_UDP_Phy', 'peer1_In_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.nc
class TestIPv4NetworkEgressDelObjandDelACECommitRollback(AclBaseAp):
    def test_verify_IPv4NetworkEgressDelObjandDelACECommitRollback(self):
        """
        Commit Rollback ipv4 acl operation to Del object group and Del ACE on Egress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.
        
        Test Procedure:
            - config IPv4 ACL and Object-group
            - Attach IPv4 ACL to Phy interface on Egress direction 
            - Delete Object group and Delete ACE
            - Single commit both changes
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Rollback last 1 config
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count 
        
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface      

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """

            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        edit config
        """

        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, )

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)
        
        """
        Verify hardware hit count on interface 
        """
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")


@pytest.mark.sfv
class TestIPv4NetworkEgressAddObjandChangeACECommitReplaceFile(AclBaseAp):
    def test_verify_Ipv4NetworkEgressAddObjandChangeACECommitReplaceFile(self):
        """
        Commit Replace ipv4 acl operation to Add object group and Change ACE on Egress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.
        
        Test Procedure:
            - config IPv4 ACL and Object-group
            - Attach IPv4 ACL to Phy interface on Egress direction 
            - Save config in file 
            - Delete Object group and Change ACE
            - Single commit both new changes
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Commit Replace with old file 
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count 
        
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface  

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """

            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['modify_addace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

        """
        commit replace to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)
        
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCPstream1', 'uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        tcp_count = int(ApData.stream_stats['uut1_TCPstream1']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_UDPstream1']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_TCPstream1']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            ApData.acl_data = ApData.zap.get_feature_configuration('acl')

@pytest.mark.spitfirefail
class TestIpv6NetworkIngressAddnDEL_Objand_ACECommitReplaceFile(AclBaseAp):
    def test_verify_Ipv6NetworkIngressAddnDEL_Objand_ACECommitReplaceFile(self):
        """
        Commit Replace ipv6 acl operation to Add/DEL object group and ACE on ingress Phy intf
        
        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.
        
        Test Procedure:
            - config IPv6 ACL and Object-group
            - Attach IPv6 ACL to Phy interface on Ingress direction 
            - Save config in file 
            - Delete Object group and Add New object group
            - Delete ACE and new ACE
            - Single commit both new changes
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Commit Replace with old file 
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count 
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface
            
        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")


        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, address_family='ipv6')
            edit_ace = ApData.acl_data['test_args']['modify_addace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

        """
        commit replace to old config
        """
        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)
        
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_UDP_Phy', 'peer1_In_IPV6_TCP_Phy']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        tcp_count = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames']
        udp_count = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames']
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')

@pytest.mark.nc
class TestIpv6NetworkIngressAddObjnDelACECommitRollback(AclBaseAp):
    def test_verify_Ipv6NetworkIngressAddObjnDelACECommitRollback(self):
        """
        Commit Rollback ipv6 acl operation to Add object group and Del ACE on Ingress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.
        
        Test Procedure:
            - config IPv6 ACL and Object-group
            - Attach IPv6 ACL to Phy interface on Ingress direction 
            - Delete Object group and Delete ACE
            - Single commit both changes
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Rollback last 1 config
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count         
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface
            

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")
        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no,address_family='ipv6' )

        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_UDP_Phy', 'peer1_In_IPV6_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        tcp_count = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames']
        udp_count = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames']
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10',address_family='ipv6')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30',address_family='ipv6')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20',address_family='ipv6')

@pytest.mark.asr
class TestIpv6NetworkEgressAddnDEL_Objand_ACECommitReplaceFile(AclBaseAp):
    def test_verify_Ipv6NetworkEgressAddnDEL_Objand_ACECommitReplaceFile(self):
        """
        Commit Replace ipv6 acl operation to Add/DEL  object group and ACE on Egress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss.  

        Test Procedure :
            - config IPv6 ACL and Object-group
            - Attach IPv6 ACL to Phy interface on Egress direction 
            - Save config in file 
            - Delete Object group and Add New object group
            - Delete ACE and new ACE
            - Single commit both new changes
            - Send traffic 
            - Verify hardware hit count on specified interface for newly changed config
            - Commit Replace with old file 
            - Verify config rollback to old config 
            - Send Traffic 
            - Verify hardware hit count 
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface  
            
        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")


        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, address_family='ipv6')
            edit_ace = ApData.acl_data['test_args']['modify_addace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

        """
        commit replace to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_IPV6_TCP_Phy', 'uut1_IPV6_UDP_Phy']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        tcp_count = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames']
        udp_count = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames']
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None, 
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10',address_family='ipv6')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30',address_family='ipv6')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20',address_family='ipv6')

@pytest.mark.nc
class TestIpv6NetworkEgressAddObjnDelACECommitRollback(AclBaseAp):
    def test_verify_Ipv6NetworkEgressAddObjnDelACECommitRollback(self):
        """
        Commit Rollback ipv6 acl operation to Add object group and Del ACE on Egress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss. 
        
        Test Procedure:
            - config IPv6 ACL and Object-group
            - Attach IPv6 ACL to Phy interface on Egress direction
            - Add Object group and DEL ACE
            - Single commit both changes 
            - Send traffic
            - Verify hardware hit count
            - Commit rollback last 1 config
            - Verify config changes rollback to old 
            - Send traffic
            - Verify hardware hit count 
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface  

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, )

        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_IPV6_TCP_Phy', 'uut1_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        tcp_count = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Tx Frames']
        udp_count = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Tx Frames']
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupEgressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')

@pytest.mark.spitfirefail
class TestIpv6NetworkIngressAddObjnChangeACE(AclBaseAp):
    def test_verify_Ipv6NetworkIngressAddObjnChangeACE(self):
        """
        Commit Replace ipv6 acl operation to add object group and Change ACE on Ingress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss. 
        
        Test Procedure:
            - config IPv6 ACL and Object-group
            - Attach IPv6 ACL to Phy interface on Ingress direction 
            - Delete Object group and Add a new ACE
            - Single commit both changes 
            - Send traffic
            - Verify hardware hit count 
            
        Configurations:
            - config ACL with Network object group
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface   

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['modify_addace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        udp_count = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames']

               
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')

@pytest.mark.spitfirefail
class TestIpv6NetworkIngressAddObjnDelACE(AclBaseAp):
    def test_verify_Ipv6NetworkIngressAddObjnDelACE(self):
        """
        Commit Replace ipv6 acl operation to add object group and Del ACE on Ingress Phy intf

        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss. 
        
        Test Procedure:
            - config IPv6 ACL and Object-group
            - Attach IPv6 ACL to Phy interface on Ingress direction 
            - Add Object group and Del ACE
            - Single commit both changes 
            - Send traffic 
            - Verify hardware hit count 
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface 

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv6_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        New config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, )

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        udp_count = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames']
               
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj2',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj5',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj1',
                network_address=None,
                host='130:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv6',
                obj_group_name='obj7',
                network_address=None,
                host='120:1::1',
                range=None,
                object_group=None,
                mode="unconfig")
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv6NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')

@pytest.mark.sfv
class TestIPv4NetworkIngressAddObjandDelACECommitReplace(AclBaseAp):
    def test_verify_IPv4NetworkIngressDeleteObjandAddACECommitReplace(self):
        """
        Commit Replace ipv4 acl operation to add and delete object group and ACE on Ingress Phy interface 
        
        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss. 
        
        Test Procedures :
            - config IPv4 ACL and Object-group
            - Attach IPv4 ACL to Phy interface on Ingress direction 
            - save config to file 
            - Delete Object group and Add a new ACE
            - Single commit both changes 
            - Send traffic
            - verify hit count
            - commit replace old file 
            - verify changes are rollback as expected
            - send traffic
            - verify hardware hit count 
            
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface  

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        """
        edit config
        """
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            seq_no = '10'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, )
        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)
        
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='15')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.sf
class TestIPv4NetworkIngressAddnDELObjandACE(AclBaseAp):
    def test_verify_IPv4NetworkIngressDeleteObjandAddACE(self):
        """
        Commit Replace ipv4 acl operation to delete object group and add ACE
        
        This test-case verifies Commit Replace feature , modification of object group and ACE changes are committed in single commit operation.
        Verify commit goes fine and traffic runs without loss 

        Test Procedure:  
            - config IPv4 ACL and Object-group
            - Attach IPv4 ACL to Phy interface on Ingress direction 
            - Delete Object group and Add a new Object group 
            - Delete existing ACE and Add a new ACE
            - Single commit both changes 
        
        Configurations:
            - config object group
            - config ACL 
            - attach to interface 
    
        Verifications:
            - Verify commit goes fine  
            - Verify hardware hit count on specified interface 

        Triggers:
            - None
        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="config")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="config")
            """
            ACL config
            """

            aclname = "ipv4_commit_rollback"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)
            """
            intf config
            """
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="config")
            seq_no = '20'
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number=seq_no, )

            edit_ace = ApData.acl_data['test_args']['modify_addace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

        """
        rollback to old config
        """
        ApData.zap.mark_config(ApData.UUT1)
        ApData.zap.rollback_config(ApData.UUT1,last=1,force=True)
        
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj = []

        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[tcp_count,rx_count1],'20':[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


    def teardown_class(self):
        with ApData.topo.config(ApData.UUT1, thread=True):
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj2',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj5',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj1',
                network_address=None,
                host='30.0.10.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_network_object_group_acl(
                address_family='ipv4',
                obj_group_name='obj7',
                network_address=None,
                host='30.0.20.1',
                range=None,
                object_group=None,
                mode="unconfig")
            acl = ApData.acl_uut.set_port_object_group_acl(
                obj_group_name='obj_port1',
                port_condition='eq',
                port_number=1024,
                mode="unconfig")
            aclname = "ipv4_commit_rollback"
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='10')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='30')
            ApData.acl_uut.delete_ace(access_list_name=aclname, sequence_number='20')
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressCommitRollback']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig")
@pytest.mark.fix5
class TestEthernetserviceVlanEgressPhySub(AclBaseAp):
    def test_EthernetserviceVlanEgressPhySub(self):
        """
        Ethernet_services acl with Vlan parameter on Egress Phy sub interface
        
        This test-case verifies Ethernet services ACL with Vlan parameter set 
        
        Test Procedures:
            - config ethernet-services ACL 
            - config ACE with Vlan parameter set 
            - Attach ethernet-services acl to l2 interface on Egress direction 
            - Send L2 Traffic 
            - Verify hardware hit count on specified interface 
        
        Configurations:
            - config ethernet-service ACL
            - Attach ACL to interface 
        Verifications:
            - Verify hardware hit count

        Triggers:
            - None:
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_egress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)
        """
        Verify Traffic
        """
        stream = ['uut2_UDP_L2intf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        verifier_obj = []
        vlan_count=ApData.stream_stats['uut2_UDP_L2intf']['Tx Frames']
            
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='20',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(vlan_count,extra = False),AclBaseAp.tolerance_value(vlan_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut2_UDP_L2intf']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'20':[vlan_count,rx_count1]},location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_egress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
@pytest.mark.fix5
class TestEthernetServiceCosEgressPhySub(AclBaseAp):
    def test_EthernetServiceCosEgressPhySub(self):
        """
        Ethernet_services acl with cos parameter on Egress Phy sub interface
        
        This test-case verifies Ethernet services ACL with COS parameter set.
        
        Test Procedures:
            - config ethernet-services ACL 
            - config ACE with COS parameter set 
            - Attach ethernet-services acl to l2 interface on Egress direction 
            - Send L2 Traffic 
            - Verify hardware hit count on specified interface 
        
        Configurations:
            - config ethernet-service ACL
            - Attach ACL to interface 
        Verifications:
            - Verify hardware hit count

        Triggers:
            - None:
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_egress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)
        """
        Verify Traffic
        """
        stream = ['uut2_L2Stream_cos']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        verifier_obj = []
        cos_count=(ApData.stream_stats['uut2_L2Stream_cos']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='40',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(cos_count,extra = False),AclBaseAp.tolerance_value(cos_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut2_L2Stream_cos']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'40':[cos_count,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_egress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.fix5
class TestEthernetServiceVlanIngressPhySub(AclBaseAp):
    def test_EthernetServiceVlanIngressPhySub(self):
        """
        Ethernet_services acl with Vlan parameter on ingress Phy sub interface
        
        This test-case verifies Ethernet services ACL with Vlan parameter set 
        
        Test Procedures:
            - config ethernet-services ACL 
            - config ACE with Vlan parameter set 
            - Attach ethernet-services acl to l2 interface on Ingress direction 
            - Send L2 Traffic 
            - Verify hardware hit count on specified interface 
        
        Configurations:
            - config ethernet-service ACL
            - Attach ACL to interface 
        Verifications:
            - Verify hardware hit count

        Triggers:
            - None:
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)
        """
        Verify Traffic
        """
        stream = ['peer2_In_udp_L2intf']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        verifier_obj = []
        vlan_count=(ApData.stream_stats['peer2_In_udp_L2intf']['Tx Frames'])
                        
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='10',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(vlan_count,extra = False),AclBaseAp.tolerance_value(vlan_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer2_In_udp_L2intf']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'10':[vlan_count,rx_count1]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig") 

@pytest.mark.fix5
class TestEthernetServiceCosIngressPhySub(AclBaseAp):
    def test_EthernetServiceCosIngressPhySub(self):
        """
        Ethernet_services acl with cos parameter on ingress Phy sub interface
        
        This test-case verifies Ethernet services ACL with COS parameter set 
        
        Test Procedures:
            - config ethernet-services ACL 
            - config ACE with COS parameter set 
            - Attach ethernet-services acl to l2 interface on Ingress direction 
            - Send L2 Traffic 
            - Verify hardware hit count on specified interface 
        
        Configurations:
            - config ethernet-service ACL
            - Attach ACL to interface 
        Verifications:
            - Verify hardware hit count

        Triggers:
            - None:
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)
        """
        Verify Traffic
        """
        stream = ['peer2_In_L2Stream_cos']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        verifier_obj = []
        cos_count=(ApData.stream_stats['peer2_In_L2Stream_cos']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number='30',
                matches=CyDiff.Range(AclBaseAp.tolerance_value(cos_count,extra = False),AclBaseAp.tolerance_value(cos_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut2_L2Stream_cos']['Rx Frames']
        try:
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={'30':[cos_count,rx_count1]},location=[ApData.hw_loc])
        except Exception as e:
                raise CafyException.CafyBaseException("ACL Hardware hit count not seen")

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ether_service_acl_ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")  
@pytest.mark.spitfire
class TestAclShowCommands(AclBaseAp):

    def test_show_acl_commands(self):

        """
        Ipv4 UDP Acl on ingress direction to Phy Interface.
        
        This test will verify ACL for udp traffic from any to any, applied on phy interface in ingress direction.
        Also verify pfilter usage, hardware details, acl on interfaces, copy acls commands.
            
        Test Procedure:
            - Config IPv4 ACL with udp any.
            - Attach IPv4 ACL to phy interface on ingress direction
            - Send traffic
            - Verify hardware hit count
        
        Configurations:
            - Config ACL with protocol type udp any

        Verifications:
            - Verify hardware hit count on specified interface, pfilter usage

        Triggers:
            None
        """
        #####################################################Attaching to the interface #################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc45']
        AclBaseAp._get_tcs_data(ApData)
        intf = ApData.intf
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        #show access list                                   
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)

        AclBaseAp.total_acl_ace_cfg(ApData)
        verifier_obj = ApData.acl_uut.SystemAclStats(current_configured_acl=str(ApData.TotalIpv4Acl), current_configured_ace=str(ApData.TotalIpv4Ace))
        expobj=ApData.acl_uut.get_acl_access_lists_summary()
        ApData.acl_uut.verify_access_lists_summary(expobj, address_family=ApData.addr_family)


         
        cli_out=ApData.acl_uut.get_acl_ace_interface(address_family=ApData.addr_family,interface = ApData.intf)
        if cli_out.ingress_acl != ApData.aclname:
            raise CafyException.VerificationError('Ingress Acl not matching')


        ##
        AclBaseAp._get_loc_int(ApData, ApData.intf)



        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames']
        ##
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        cli_out=ApData.acl_uut.get_access_list_usage_pfilter(location = 'all', address_family="ipv4")
        if cli_out['acl_usage'][ApData.intf.lower()]['ingress'] == ApData.aclname:
            ApData.log.info('Pfilter verification passed')
        else:
            raise CafyException.VerificationError('Pfilter usage exception')
        copyacl='copyacl'
        ApData.acl_uut.copy_acl(source_access_list_name=ApData.aclname,address_family=ApData.addr_family,destination_access_list_name=copyacl,unit_test_mode=False)
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=copyacl)
        ApData.log.info(ace_list)
            

    def teardown_class(self):
        copyacl='copyacl'
        ApData.acl_uut.delete_acl(access_list_name=copyacl, unit_test_mode=False)
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc45']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

@pytest.mark.fix5
class TestAclOnShutInterface(AclBaseAp):

    def test_acl_shut_interface(self):
        """
        Flap phy interface and verify tarffic on wrong interface.

        This test will flap the physical interface and verify Acl for Tcp traffic on phy interface.

        Test Procedure:
            - Config Ipv4 acl on shut interface
            - Applied Acl to Physical interface in egress direction
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           

        Verifications:
            - Verifying the traffic hit count and there is no traffic loss.

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc66']
        AclBaseAp._get_tcs_data(ApData)
        ApData.intf = ApData.UUT1.get_local(ApData.link).name


        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
                                    
        with pytest.allure.step('Shut the interface'):
            ApData.uut1_ifmgr.shut(ApData.interfaces['R1_R2_3.R1'].name)
            Helper.sleep(20, msg='waiting for interface and protocols to go '
                                 'down')
        with pytest.allure.step('Verify the interface status'):
            ApData.uut1_ifmgr.verify_shut([ApData.interfaces['R1_R2_3.R1'].name])



        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_UDPstream1']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_UDPstream1']['Tx Frames']
        actual_match = ApData.acl_uut.get_acl_access_lists_ipv4_hardware(address_family=ApData.addr_family,access_list_name=ApData.aclname, 
        direction=ApData.dir,interface=None, location=ApData.hw_loc)
        matches_hardware = actual_match[0].matches
        rxcount = ApData.stream_stats['uut1_UDPstream1']['Rx Frames']
        if matches_hardware and matches != rxcount:
            raise CafyException.VerificationError('Traffic matched for a wrong interface')
               
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc66']
        AclBaseAp._get_tcs_data(ApData)
        with pytest.allure.step('Unshut the interface'):
            ApData.uut1_ifmgr.noshut([ApData.interfaces['R1_R2_3.R1'].name])
            self.success = True
            Helper.sleep(20, msg='waiting for interface to come up')

        with pytest.allure.step('Verify the interface status'):
            ApData.uut1_ifmgr.verify_noshut([ApData.interfaces['R1_R2_3.R1'].name]) 
        ApData.intf = ApData.UUT1.get_local(ApData.link).name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")                                  
@pytest.mark.fix5
class TestIpv6RoutingHopbyHop(AclBaseAp):

    def test_ipv6_routing_hopbyhop(self):
        """
        IPV6 Acl with Routing, Hop by Hop as Packet header.
        
        This test will verify Ipv6 ACL for tcp traffic with different packet header length, applied on phy sub interface in Ingress direction.
            
        Test Procedure:
            - Config IPv6 ACL with tcp.
            - Attach IPv6 ACL to phy sub interface on ingress direction
            - Send traffic
            - Verify hardware hit count
        
        Configurations:
            - Config ACL with protocol type tcp

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['hopbyhop']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['aclnames'][aclname]
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        AclBaseAp._get_loc_int(ApData, intf2)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
       
        stream_start = ['peer1_In_IPv6_TCP_Routing','peer1_In_IPv6_Udp_dest_head']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream_start, expected=0)
        matches = []        
        for i in range(0, len(stream_start)):
            seq = int(aclname_data[0]['sequence_number'])
            seq = int(seq) + i
            matches.append((ApData.stream_stats[stream_start[i]]['Tx Frames']))
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches[i],extra = False),AclBaseAp.tolerance_value(matches[i],extra = True))))
            """
            Verify hardware hit count on interface 
            """  
            rx_count1 = ApData.stream_stats[stream_start[i]]['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches[i],rx_count1]},location=[ApData.hw_loc])

    
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['hopbyhop']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
                                            
##################################################################################################################################                                          


@pytest.mark.fix5
class TestIpv4NetworkPhySubEgressAclNetworkAddressCompressLevel1(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL
        
        Apply acl to an Egress interface with compressand verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_port_group_network_group_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkPhySubEgressAclNetworkAddressCompressLevel1(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Egress PhySub intf with Compress Level 1
        
        This test-case verifies Object group and hybrid acl compression level at 1 enable on interface

        Test Procedure:
            - Config Ipv4 Network Object group with Network Address parameter 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to PhySub interface on Egress direction with compress level 1 
            - Send traffic  
            - Verify hardware hit count on interface 

        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
            
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupEgressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_TCP_PhySub', 'uut1_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_stream_total = int(ApData.stream_stats['uut1_TCP_PhySub']['Tx Frames'])
        udp_stream_total = int(ApData.stream_stats['uut1_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_stream_total,extra = False),AclBaseAp.tolerance_value(tcp_stream_total,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_stream_total,extra = False),AclBaseAp.tolerance_value(udp_stream_total,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_stream_total,rx_count1],seq[1]['sequence_number']:[udp_stream_total,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.10.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='130.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="unconfig")

@pytest.mark.fix5
class TestIPv6NetworkPhySubEgressAclHostAddressCompressLevel1(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="config")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_port_group_network_group_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkPhySubEgressAclHostAddressCompressLevel1(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Egress PhySub intf with Compress Level1
                
        This test-case verifies Object group and hybrid acl compression level at 1  enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to PhySub interface on Egress direction with compress level 1 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count 
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupEgressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['uut1_IPV6_TCP_Physub', 'uut1_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv6_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []    
        tcp_count = int(ApData.stream_stats['uut1_IPV6_TCP_Physub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Tx Frames'])
            
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_IPV6_TCP_Physub']['Rx Frames']
        rx_count2 = ApData.stream_stats['uut1_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)
        
        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='130:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="unconfig")


@pytest.mark.fix5
class TestIPv6NetworkIngressAclHostAddressCompressLevel1(AclBaseAp):
    def setup_class(self):
        """
        Create IPv6 network object group and create ACL
        
        
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv6_permit_tcp_port_group_network_group_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_IPv6NetworkIngressAclHostAddressCompressLevel1(self):
        """
        IPV6 Network Object-Group parameter Host Address type set on Ingress Phy intf with Compress Level 1
        
        This test-case verifies Object group and hybrid acl compression level at 1 enable on interface

        Test Procedure:
            - Config Ipv6 Network Object group with host Address parameter 
            - Config Ipv6 ACL with ACE that contains object group 
            - Attach ACL to PhySub interface on Ingress direction with compress level 1 
            - Send traffic  
            - Verify hardware hit count on interface 
        
        Configurations:
            - Config ACl 
            - Attach to interface
        
        Verifications:
            - Verify hardware hit count
        
        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_Phy', 'peer1_In_IPV6_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)

        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        """
        Apply acl to PhySub interface
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['IPv6NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_IPV6_TCP_PhySub', 'peer1_In_IPV6_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]

        verifier_obj = []
        tcp_count = int(ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Tx Frames'])
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_IPV6_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_IPV6_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc])

        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv6',
            obj_group_name='network_object_group_host_ipv6',
            network_address=None,
            host='120:1:1::1',
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="unconfig")


@pytest.mark.fix5
class TestIpv4NetworkIngressAclNetworkAddressCompresslevel1(AclBaseAp):
    def setup_class(self):
        """
        Create network object group and create ACL
        
        Apply acl to an Ingress interface with compress and verify the tx and rx from traffic stream.
        Also verify the hardware matches from show command
        :return: None
        """
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.20.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='120.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="config")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="config")
        """
        Apply object group to ACE 
        """
        aclname = "ipv4_permit_tcp_port_group_network_group_compress"
        edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
        ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_verify_Ipv4NetworkIngressAclNetworkAddressCompresslevel1(self):
        """
        IPV4 Network Object-Group parameter Network Address type set on Ingress Phy intf with Compress Level 1
        
        This testcase Verify Object group with network type  and enabling Hybrid ACL with compression level 1 on Ingress direction
        
        Test Procedures:
            - Config Ipv4 Network Object group with Network Address parameter 
            - Config Ipv4 ACL with ACE that contains object group 
            - Attach ACL to Phy interface on Ingress direction with compress level 1
            - Send traffic
            - Verify hardware hit count on expected ACE 
            - clean config 
        
        
        Configurations: 
            - create object group with network type
            - config ACL 
            - Attach ACL to interface and enable compress level 1 
            
        Verifications: 
            - Verify hardware hit count on interface 

        Triggers:
            - None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressAclPhy']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_Phy']['Tx Frames'])
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc],add_ace=True)


        """
        Unconfig interface 
        """
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        """
        ACL config on phy
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['NetworkObjectGroupIngressAclPhySub']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        AclBaseAp._get_loc_int(ApData, ApData.intf)

        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        aclname1 = "ipv4_permit_tcp_obj_group_any_compress"
        seq = ApData.acl_data['test_args']['add_ace'][aclname1]
        tcp_count = int(ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames'])
        udp_count = int(ApData.stream_stats['peer1_In_UDP_PhySub']['Tx Frames'])

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[0]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(tcp_count,extra = False),AclBaseAp.tolerance_value(tcp_count,extra = True))))
                
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq[1]['sequence_number'],
                matches=CyDiff.Range(AclBaseAp.tolerance_value(udp_count,extra = False),AclBaseAp.tolerance_value(udp_count,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count2 = ApData.stream_stats['peer1_In_UDP_PhySub']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq[0]['sequence_number']:[tcp_count,rx_count1],seq[1]['sequence_number']:[udp_count,rx_count2]},location=[ApData.hw_loc])


        """
        Unconfig interface 
        """

    def teardown_class(self):
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='30.0.20.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_network_object_group_acl(
            address_family='ipv4',
            obj_group_name='network_object_group_host',
            network_address='120.1.1.0/24',
            host=None,
            range=None,
            object_group=None,
            mode="unconfig")
        acl = ApData.acl_uut.set_port_object_group_acl(
            obj_group_name='obj_port_compress',
            port_condition='range',
            port_number='1023 1030',
            mode="unconfig")
            
@pytest.mark.sf
class TestIpv4AddandRemoveBundleMembersIngress(AclBaseAp):

    def test_Ipv4_Add_and_Remove_Bundle_Members_Ingress(self):
        """
        Ipv4 TCP permit Acl on ingress Bundle Interface.
        
        This test will verify ACL  applied on Bundle interface in ingress direction,Add and remove members .
        
        Test Procedure:
            - Config IPv4 ACL with TCP any any
            - Attach IPv4 ACL to bundle interface on ingress direction
            - Send traffic
            - Verify hardware hit count
        
        Configurations:
            - Config ACL with TCP any to any

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc3']
        AclBaseAp._get_bun_data(ApData)
        
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                     direction=ApData.dir,
                                     interface=ApData.intf, mode="config")
            
        stream = ['peer2_In_TCP_Bundle']
        loc=[]
        ApData.intf1 = ApData.member[0].interface
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        
        loc.append(ApData.hw_loc)
        ApData.verify_Bundle_TC(self,acl=ApData.aclname,sequance_no=seq,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)
        ApData.log.banner(" #############################################\n")
        ApData.log.banner("**** removing member 0 from bundle interface \n")
        ApData.log.banner(" #############################################\n")
        
        ApData.uut1_ifmgr.remove_bundle_interface(ApData.intf1)
        ApData.linkp = ApData.zap.get_link('R1_R2_1')
        ApData.intf_peer = ApData.UUT1.get_remote(ApData.linkp).name   
        ApData.peer1_ifmgr.remove_bundle_interface(ApData.intf_peer)
        
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        member2_loc= ApData.hw_loc
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer2_In_TCP_Bundle']['Tx Frames']
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        
        
        rx_count1 = ApData.stream_stats['peer2_In_TCP_Bundle']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])

        
        """"
        add bundle interface
        """
        ApData.log.banner("#############################################\n")
        ApData.log.banner("***** adding back member 0 to bundle interface \n")
        ApData.log.banner(" #############################################\n")
        ApData.uut1_ifmgr.add_bundle_interface(ApData.intf1,'Bundle-Ether500')
        ApData.peer1_ifmgr.add_bundle_interface(ApData.intf_peer,'Bundle-Ether500')
        
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.verify_Bundle_TC(self,acl=ApData.aclname,sequance_no=seq,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer2_In_TCP_Bundle']['Tx Frames']
        
        verifier_obj=[]
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        
        
        rx_count1 = ApData.stream_stats['peer2_In_TCP_Bundle']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])
       
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc3']
        AclBaseAp._get_bun_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                     direction=ApData.dir,
                                     interface=ApData.intf, mode="unconfig")  

@pytest.mark.f
class TestIpv4DenyTcpUniqueAcl(AclBaseAp):
    def test_deny_unique_acl(self):
        """
        Ipv4 TCP deny Acl on ingress direction to both Phy and Phy-sub Interface.
                                        
        This test will apply an acl to multiple interface and verify hit count by combining tarffic stats.
        
        Test Procedure:
            - Config IPv4 ACL
            - Attach ACL to Phy and Phy sub interface on Ingress direction
            - Send traffic and Verify hit count on combining hitcount.
            
        Configurations:
            - configuring Acl and Attaching to the interface.           
            
        Verifications:
            -  Verifying the traffic hit count.
           
        Triggers:
            - None
            
        """
        #####################################################Attaching to the interface #################################################
        AclBaseAp.reload_module(ApData)
        ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        intf = ApData.intf
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        ace_list = ApData.acl_uut.get_acl_ace_oper(access_list_name=ApData.aclname)
        ApData.log.info(ace_list)
        
        AclBaseAp._get_loc_int(ApData, intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        stream = ['peer1_In_TCP_Phy', 'peer1_In_TCP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        match1 = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        match2 = ApData.stream_stats['peer1_In_TCP_PhySub']['Tx Frames']

        matches = int(match1) + int(match2)
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_match1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        rx_match2 = ApData.stream_stats['peer1_In_TCP_PhySub']['Rx Frames']
        rx_count = int(rx_match1)+ int(rx_match2)
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

class Test_spitfire_ipv4_multiple_aces_with_Process_Crash_on_ingress_egress(AclBaseAp):

    @pytest.mark.parametrize('process',
                             ["pfilter_ma", "pfilter_ea", "ipv4_acl_mgr", "ipv6_acl_daemon", "obj_mgr", "sysdb_mc",
                              "ifmgr", "netio"])
    def test_spitfire_verify_multiple_aces_on_ipv4_with_Process_Crash(self, process):
        """
        spitfire Process crash on Multiple v4 Aces.
        
        This will Create Multiple Ipv4 aces which are Attached to Ingress and Egress Interface and their is Addition
        of Ace to an existing ACL and traffic is passed to hit the traffic match count and triggers are started and the same 
        procedure for the traffic is verified.
        
        Test Procedure:
            - Config Multiple IPv4 ACL which has tcp,udp,ospf
            - Attach ACL to Phy interface on Ingress direction
            - Add the Ace to the existing ACL
            - Send traffic 
            - Verify packet for the added ace which has hit count.
            - Process to be crashed is triggered 
            - Verification of Respawn count is checked.
            - The same Traffic is passed to verify the hit counters.            
        
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Process Crash.
        
        
        """
        #
        #####################################################Attaching to the interface #################################################
        list1 = ['Tc6', 'Tc8']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")
        ##############################################Adding the aces############################################################

        test_case_name = ApData.acl_data['test_args']['apply_intf']
        for i in list1:
            acl_data = test_case_name[i]
            aclname = acl_data['aclname']
            aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(aclname_data, ApData.acl_uut, aclname)
        ###########################Egress#######################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)
        ###################################################Traffic verification on Ingress #####################################################
        ###################################################Traffic verification on Ingress #####################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc8']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)

        ####################################################################################################################################

        device = ApData.UUT1
        process1 = Process(device=device, mode=ApData.mode)
        location = ApData.hw_loc
        try:
            process_obj = process1.ProcessCrash(process1, process, location=location)
            process_obj.launch()
            process_obj.checker()
        except Exception as exception_error:
            log.error(exception_error)
        #
        #########################################################################################
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc6']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['uut1_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut1_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['uut1_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)

        ###################################################Traffic verification on Ingress #####################################################

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Tc8']
        AclBaseAp._get_tcs_data(ApData)
        aclname = ApData.aclname
        aclname_data = ApData.acl_data['test_args']['add_ace'][aclname]
        seq = aclname_data[0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        stream = ['peer1_In_Ospf_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['peer1_In_Ospf_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_Ospf_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc],add_ace=True)


    #####################################################################################################################################################

    def teardown_class(self):
        list1 = ['Tc6', 'Tc8']
        for i in list1:
            ApData.test_case = ApData.acl_data['test_args']['apply_intf'][i]
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="unconfig") 
@pytest.mark.sf
class TestIpv4ACETCPEstablishedHostPerBundleEgress(AclBaseAp):

    def test_ipv4_ACE_TCP_Established_host_per_bundle_egress(self):
        """
        Addressing BUG:CSCvm01102 Ipv4 TCP(Host) permit Acl  Established as protocol argument on  egress direction to Bundle Interface.
        
        This test will verify ACL for TCP traffic from host to host, applied on bundle interface in egress direction.
            
        Test Procedure:
            - Config IPv4 ACL with TCP host with elstablished flag enabled
            - Attach IPv4 ACL to bundle interface on egress direction
            - Send traffic TCP established packet
            - Verify hardware hit count for TCP elstablished packet
            - Send traffic with only syc flag enabled 
            - Verify hardware hit count should not be hit
        
        Configurations:
            - Config ACL with protocol type TCP host

        Verifications:
            - Verify hardware hit count on specified interface

        Triggers:
            None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['TCP_establish']
        AclBaseAp._get_bun_data(ApData)
        
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                     direction=ApData.dir,
                                     interface=ApData.intf, mode="config")
        loc=[]
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        stream = ['uut2_TCP_Bundle']
        ApData.verify_Bundle_TC(self,acl=ApData.aclname,sequance_no=seq,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut2_TCP_Bundle']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        rx_count = ApData.stream_stats['uut2_TCP_Bundle']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number'] :[matches,rx_count]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])
        stream = ['uut2_bundle_tcp_established']
        ApData.verify_Bundle_TC(self,acl=ApData.aclname,sequance_no=seq,TX_frame=0, addr_family=ApData.addr_family,dir=ApData.dir, location= loc ,clear=True, verify=False)

        AclBaseAp.traffic_verifier(ApData, stream_name=stream)
        matches = ApData.stream_stats['uut2_bundle_tcp_established']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                               matches=0))
        rx_count = ApData.stream_stats['uut2_bundle_tcp_established']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number'] :[matches,rx_count]},location=[ApData.bundle_members_location[0],ApData.bundle_members_location[1]])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['TCP_establish']
        AclBaseAp._get_bun_data(ApData)
        ApData.intf = ApData.interfaces[ApData.intfl].name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")
@pytest.mark.fix5  
class TestRemoveAcl(AclBaseAp):

    def test_remove_acl(self):

        """
        Remove Acl and check logging errors.
        
        This test will remove all acls and check for logging errors
            
        Test Procedure:
            - Remove all acls
            - Validate logging errors
        
        Configurations:
            - Remove acls.

        Verifications:
            - Verify logging errors.

        Triggers:
            None
        """
        #
        ApData.acl_data = ApData.zap.get_feature_configuration('acl')
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.zap.remove_acl(ApData.acl_data, ApData.acl_uut)

@pytest.mark.testspitfire
class TestTriggersAcl(AclBaseAp):
    
    def setup_class(self):
        """
        Apply IPv4 Acl to phy interface.
        :return: None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

    def test_system_reload_active(self):
        """
        Ipv4 traffic after LC reload, RPFO and active node reload.
        
        Test Procedure:
            - Reload LC/RPFO
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Reload LC/RPFO
            
        """
        
        with pytest.allure.step("Before reload scenarios"):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
            AclBaseAp._get_tcs_data(ApData)
            seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
            stream = ['peer1_In_TCP_Phy']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
         
        with pytest.allure.step("Verify hardware hit count on interface before active RP reload"):
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
       
        
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        device = ApData.UUT1
        ApData.event_runner = Event(device=device, mode=ApData.mode)
        ApData.inventory = Inventory(device=device, mode=ApData.mode)
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        verifiers = CafyTriggers()
        card_triggers = CafyTriggers()
        card_triggers.add(ApData.event_runner.ReloadActiveRP(
                        inv_obj=ApData.inventory, preVerify=False,nsr=True))
        verifiers.addTrigger(card_triggers)
        verifiers.run()

        
        with pytest.allure.step("After reload scenarios"):
            ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
                                       
        
                                       
        
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        with pytest.allure.step("Verify hardware hit count on interface"):
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])

        
    def test_system_reload_rpfo(self):
        """
        Ipv4 traffic after LC reload, RPFO and active node reload.
        
        Test Procedure:
            - Reload LC/RPFO
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Reload LC/RPFO
            
        """
        with pytest.allure.step("Before reload scenarios"):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
            AclBaseAp._get_tcs_data(ApData)
            seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
            stream = ['peer1_In_TCP_Phy']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
         
        with pytest.allure.step("Verify hardware hit count on interface before RPFO"):
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
       
        
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
       
        device = ApData.UUT1
        ApData.event_runner = Event(device=device, mode=ApData.mode)
        ApData.inventory = Inventory(device=device, mode=ApData.mode)
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        verifiers = CafyTriggers()
        card_triggers = CafyTriggers()
               
        card_triggers.add(ApData.event_runner.RedundancySwitchOver(inv_obj=ApData.inventory,nsr=True))
        verifiers.addTrigger(card_triggers)
        verifiers.run()

        with pytest.allure.step("After reload scenarios"):
            ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
                                       
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        with pytest.allure.step("Verify hardware hit count on interface after RPFO"):
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def test_system_reload_lc_oir(self):
        """
        Ipv4 traffic after LC reload, RPFO and active node reload.
        
        Test Procedure:
            - Reload LC/RPFO
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Reload LC/RPFO
            
        """
        with pytest.allure.step("Before reload scenarios"):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
            AclBaseAp._get_tcs_data(ApData)
            seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
            stream = ['peer1_In_TCP_Phy']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
         
        with pytest.allure.step("Verify hardware hit count on interface before lc reload"):
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
       
        
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
       

        device = ApData.UUT1
        ApData.event_runner = Event(device=device, mode=ApData.mode)
        ApData.inventory = Inventory(device=device, mode=ApData.mode)
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        verifiers = CafyTriggers()
        card_triggers = CafyTriggers()    
        card_triggers.add(ApData.event_runner.ReloadCard(inv_obj=ApData.inventory, location=ApData.hw_loc,preVerify=False))
        verifiers.addTrigger(card_triggers)
        verifiers.run()

        
        with pytest.allure.step("After reload scenarios"):
            ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
                                       
        
                                       
        
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        with pytest.allure.step("Verify hardware hit count on interface after lc reload"):
            matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        
            rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])


    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

class TestHATriggersAcl(AclBaseAp):
    
    def setup_class(self):
        """
        Apply IPv4 Acl to phy interface.
        :return: None
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

    def test_system_reload_all_cards(self):
        """
        Ipv4 traffic after LC reload, RPFO and active node reload.
        
        Test Procedure:
            - Reload LC/RPFO
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Reload LC/RPFO
            
        """
        
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        ApData.log.info("Before reload scenarios")
        stream = ['peer1_In_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
       

        device = ApData.UUT1
        ApData.event_runner = Event(device=device, mode=ApData.mode)
        ApData.inventory = Inventory(device=device, mode=ApData.mode)
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        verifiers = CafyTriggers()
        card_triggers = CafyTriggers()
        card_triggers.add(ApData.event_runner.ReloadAllCards(
                        inv_obj=ApData.inventory))
        verifiers.addTrigger(card_triggers)
        verifiers.run()

        ApData.log.info("After reload scenarios")
        ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",active_rp=ApData.UUT1.inventory.get_xr_active_rp())
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
                                       
        
                                       
        
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
    def test_system_reload_rpfo_continuos_traffic(self):
        """
        Ipv4 traffic after LC reload, RPFO and active node reload.
        
        Test Procedure:
            - Reload LC/RPFO
            - Verified by passing the particular stream of ACE to match the hit counter.
            
        Configurations:
            - Configuring Acl and Attaching to the interface.           
            
        Verifications:
            - Verifying the traffic hit count and no traffic loss.
            
        Triggers:
            - Reload LC/RPFO
            
        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
        ApData.log.info("Before reload scenarios")
        stream = ['peer1_In_TCP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream, expected=0)
        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']

        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
        
        
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)
                        
        AclBaseAp._get_loc_int(ApData, ApData.intf)
        ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                       direction=ApData.dir,
                                       interface=None, location=ApData.hw_loc)

        ApData.stream_handle = ApData.Tgen.get_all_traffic_streams()
        ApData.log.info(ApData.stream_handle)
        ApData.stream_name = ApData.Tgen.get_traffic_items()
        ApData.log.info(ApData.stream_name)
        stream_name=stream
        expected=0

        if not ApData.Tgen.verify_arp_status():
           ApData.log.info("ARP status verification has failed")

        ApData.Tgen.start_traffic(traffic_list=stream_name)      
        Helper.sleep(10, msg='Letting the traffic to run for RPFO period')
        
        device = ApData.UUT1
        ApData.event_runner = Event(device=device, mode=ApData.mode)
        ApData.inventory = Inventory(device=device, mode=ApData.mode)
        ApData.active_rp = ApData.inventory.get_xr_active_rp()
        verifiers = CafyTriggers()
        card_triggers = CafyTriggers()
        card_triggers.add(ApData.event_runner.RedundancySwitchOver(inv_obj=ApData.inventory,nsr=True))
        verifiers.addTrigger(card_triggers)
        verifiers.run()
        
        ApData.Tgen.stop_traffic(traffic_list=stream_name)
        
        traffic_stats = {}
        try:
           traffic_stats = ApData.Tgen.verify_traffic(tolerance=5,expected=None)
           ApData.log.info(traffic_stats)
        except Exception as e: 
            traffic_stats = e
            traffic_stats = traffic_stats.args[0]

        ApData.stream_stats = {}
        item_stats = traffic_stats[0]
        flow_stats = traffic_stats[1]
        
        if stream_name is not None:
            for j in range(0,len(stream_name)):
                for i in range(1, len(item_stats)+1):
                    str_name = item_stats[i]['Traffic Item']
                    ApData.stream_stats[str_name] = item_stats[i]
                    if str_name == stream_name[j]:
                       break    
                ApData.txcount = ApData.stream_stats[stream_name[j]]['Tx Frames']
                ApData.rxcount = ApData.stream_stats[stream_name[j]]['Rx Frames']
                ApData.log.info(ApData.txcount)
                ApData.log.info(ApData.rxcount)
                ApData.log.info(ApData.stream_stats[stream_name[j]])
                
        else:
           
            for i in range(1, len(item_stats)+1):
                str_name = item_stats[i]['Traffic Item']
                ApData.stream_stats[str_name] = item_stats[i]
                if str_name == stream_name:
                   break
                
                ApData.txcount = ApData.stream_stats[str_name]['Tx Frames']
                ApData.rxcount = ApData.stream_stats[str_name]['Rx Frames']
                ApData.log.info(ApData.txcount)
                ApData.log.info(ApData.rxcount)
                ApData.log.info(ApData.stream_stats[str_name])
    

        ApData.log.info("After RPFO with continuos traffic scenarios")


        matches = ApData.stream_stats['peer1_In_TCP_Phy']['Tx Frames']
        verifier_obj = []
        verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname,sequence_number=seq,
                matches=CyDiff.Range(AclBaseAp.tolerance_value(matches,extra = False),AclBaseAp.tolerance_value(matches,extra = True))))
        """
        Verify hardware hit count on interface 
        """  
        rx_count1 = ApData.stream_stats['peer1_In_TCP_Phy']['Rx Frames']
        ApData.acl_uut.get_acl_hit_count(ApData,expected_data_obj=verifier_obj,traffic={seq:[matches,rx_count1]},location=[ApData.hw_loc])
    
    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['tc63']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


        
@pytest.mark.qos2
class TestQosGroupAclIngress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 port object group and create ACL.

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        with pytest.allure.step("Enable hw_module profile for qos"):
            hw_qos = QosHwXrCli(device=ApData.UUT1)
            hw_qos.set_ingress_model_peering()
            AclBaseAp._set_VmReload(ApData)
        with pytest.allure.step("Config ACL "):
            aclname = "qos_acl"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_qos_group_acl_Ingress(self):
        """
        Qos Group peering classmap and policymap with ACL in ingress direction

        This test will apply service policy on egress interface

        Test Procedure:
            - Create calss map and policymap with ACL.
            - And apply service poilcy Phy ingress interface.
            - Verify acl hit count

        Configurations:
            - configuring Class map and policy map.
            - Apply the policy to ingress interface.

        Verifications:
            -  Verifying the ACL hit count.

        Triggers:
            - None

        """
        log.banner("Apply class map and policy map on acl configured session")
        ApData.UUT1_interfaces = ApData.zap.get_interfaces(device=ApData.UUT1)
        ApData.ifmgr = IfMgr(device=ApData.UUT1, mode=ApData.mode)
        ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",
                             active_rp=ApData.UUT1.inventory.get_xr_active_rp())

        with pytest.allure.step("Apply class map and policy map"):
            device = ApData.UUT1
            ApData.qos_data = ApData.zap.get_feature_configuration('qos_group')
            ApData.classmap_inst = ClassMap(device=device, mode='cli')
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst)
            ApData.policymap_inst = PolicyMap(device=device, mode='cli')
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst)
            ApData.test_data = ApData.zap.get_feature_configuration("qos_args_group_input")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data)
            Helper.sleep(10, msg='applying policy map')


            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['qos_acl']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

            link = ApData.zap.get_link("R1_R2_3")
            intf = ApData.UUT1.get_local(link).name

            stream = ['peer1_In_TCP_Prec']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream)
            matches = ApData.stream_stats['peer1_In_TCP_Prec']['Tx Frames']
            policy_map_expected_values = []
            policy = ApData.test_data['R1_R2_3.R1']['input']

            expected_values = PolicyMap.PolicerMapData(policy_name=policy, classmap_name=policy,
                                                       matched_pkts=matches)
            policy_map_expected_values.append(expected_values)

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']
            verifier_obj = []
            verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                                               matches=CyDiff.Range(
                                                                   AclBaseAp.tolerance_value(matches, extra=False),
                                                                   AclBaseAp.tolerance_value(matches, extra=True))))
            rx_count = ApData.stream_stats['peer1_In_TCP_Prec']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.hw_loc],add_ace='add_ace')

    def teardown_class(self):
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['qos_acl']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                     direction=ApData.dir,
                                     interface=ApData.intf, mode="unconfig")
            ApData.zap.configure_service_policy(
            ApData.UUT1_interfaces,
            ApData.ifmgr,
            ApData.test_data, config_mode="delete")
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst, config_mode="delete")
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst, config_mode="delete")
            ApData.acl_uut.delete_acl(access_list_name=ApData.aclname, unit_test_mode=False)
            hw_qos = QosHwXrCli(device=ApData.UUT1)
            hw_qos.set_ingress_model_peering(enable=False)

@pytest.mark.qos2
class TestIpv6QosGroupAclIngress(AclBaseAp):
    def setup_class(self):
        """
        Create IPv4 port object group and create ACL.

        Apply acl to an ingress interface and verify the tx and rx from traffic stream.
        :return: None
        """
        with pytest.allure.step("Enable hw_module profile for qos"):
            hw_qos = QosHwXrCli(device=ApData.UUT1)
            hw_qos.set_ingress_model_peering()
            AclBaseAp._set_VmReload(ApData)
        with pytest.allure.step("Config ACL "):
            aclname = "qos_ipv6_acl"
            edit_ace = ApData.acl_data['test_args']['add_ace'][aclname]
            ApData.zap.edit_add_aclace(edit_ace, ApData.acl_uut, aclname)

    def test_IPv6_qos_group_acl_Ingress(self):
        """
        Qos Group peering class map and policymap with IPV6 ACL in ingress direction

        This test will apply service policy on ingress interface

        Test Procedure:
            - Create calss map and policymap with ACL.
            - And apply service poilcy Phy ingress interface.
            - Verify ACL hit count.

        Configurations:
            - configuring Class map and policy map.
            - Apply the policy to ingress interface.

        Verifications:
            -  Verifying the ACL hit count.

        Triggers:
            - None

        """
        log.banner("Apply class map and policy map on acl configured session")
        ApData.UUT1_interfaces = ApData.zap.get_interfaces(device=ApData.UUT1)
        ApData.ifmgr = IfMgr(device=ApData.UUT1, mode=ApData.mode)
        ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",
                             active_rp=ApData.UUT1.inventory.get_xr_active_rp())


        with pytest.allure.step("Apply class map and policy map"):
            device = ApData.UUT1

            ApData.qos_data = ApData.zap.get_feature_configuration('qos_group_ipv6')
            ApData.classmap_inst = ClassMap(device=device, mode='cli')
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst)
            ApData.policymap_inst = PolicyMap(device=device, mode='cli')
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst)
            ApData.test_data = ApData.zap.get_feature_configuration("qos_args_group_ipv6_input")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data)
            Helper.sleep(10, msg='applying policy map')


            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['qos_ipv6_acl']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir,
                                                interface=ApData.intf, mode="config")

            AclBaseAp._get_loc_int(ApData, ApData.intf)
            ApData.acl_uut.clear_acl_stats(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

            link = ApData.zap.get_link("R1_R2_3")
            intf = ApData.UUT1.get_local(link).name

            stream = ['peer1_In_IPv6_tcp_prec']
            AclBaseAp.traffic_verifier(ApData, stream_name=stream)
            matches = ApData.stream_stats['peer1_In_IPv6_tcp_prec']['Tx Frames']
            policy_map_expected_values = []
            policy = ApData.test_data['R1_R2_3.R1']['input']

            expected_values = PolicyMap.PolicerMapData(policy_name=policy, classmap_name=policy,
                                                       matched_pkts=matches)
            policy_map_expected_values.append(expected_values)
            AclBaseAp._get_loc_int(ApData, ApData.intf)
            seq = ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']

            verifier_obj = []
            verifier_obj.append(ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number='10',
                                                               matches=CyDiff.Range(
                                                                   AclBaseAp.tolerance_value(matches, extra=False),
                                                                   AclBaseAp.tolerance_value(matches, extra=True))))
            rx_count = ApData.stream_stats['peer1_In_IPv6_tcp_prec']['Rx Frames']
            ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj, traffic={
                ApData.acl_data['aclnames'][ApData.aclname][0]['sequence_number']: [matches, rx_count]},
                                             location=[ApData.hw_loc],add_ace='add_ace')

    def teardown_class(self):
        with ApData.topo.config(ApData.UUT1, thread=True):
            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['qos_ipv6_acl']
            AclBaseAp._get_tcs_data(ApData)
            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                     direction=ApData.dir,
                                     interface=ApData.intf, mode="unconfig")
            ApData.zap.configure_service_policy(
                ApData.UUT1_interfaces,
                ApData.ifmgr,
                ApData.test_data, config_mode="delete")
            ApData.zap.configure_policymaps(ApData.qos_data, ApData.policymap_inst, config_mode="delete")
            ApData.zap.configure_classmaps(ApData.qos_data, ApData.classmap_inst, config_mode="delete")
            ApData.acl_uut.delete_acl(access_list_name=ApData.aclname, unit_test_mode=False)
            hw_qos = QosHwXrCli(device=ApData.UUT1)
            hw_qos.set_ingress_model_peering(enable=False)


@pytest.mark.bct
class TestIpv4CommonACLIngress(AclBaseAp):
    def setup_class(self):
        """
        Config hardware profile to enable common ACL

        :return: None
        """
        ApData.acl_uut.set_hardware_profile_common_acl()
        AclBaseAp._set_VmReload(ApData)
        ApData.acl_uut = Acl(device=ApData.UUT1, mode=ApData.mode, name="acl",
                             active_rp=ApData.UUT1.inventory.get_xr_active_rp())

    def test_ipv4_CommonACLPhyIngress(self):
        """
        Ipv4 Common ACL on Ingress Phy intf

        This test-case verifies 2 level ACL Chaining
        When traffic hits on interface common ACL is verified frist and then interface ACL in chaining fashion.

        Test Procedure:
            - Config 2 diff Ipv4 ACL
            - Attach 1 interface ACL and 1 common ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACL
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.topo = ApData.zap.get_topology()
        with ApData.topo.config(ApData.UUT1, thread=True):
            """
            attach common ACL
            """

            ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclPhy_ingress']
            AclBaseAp._get_tcs_data(ApData)

            ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                                direction=ApData.dir, interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv4_chain_acl']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """

        stream = ['peer1_In_TCP_Phy', 'peer1_In_UDP_Phy']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """

        tx_data = {'ipv4_chain_acl': ['peer1_In_UDP_Phy', '20'], 'ipv4_chain_common_acl': ['peer1_In_TCP_Phy', '50']}

        for aclname in tx_data.keys():
            matches = ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
            seq = tx_data[aclname][1]
            ApData.aclname = aclname
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']

            if aclname == 'ipv4_chain_common_acl':
                ApData.acl_uut.verify_common_acl_hit_count(expected_data_obj=verifier_obj,
                                                           access_list_name=ApData.aclname,
                                                           addr_family=ApData.addr_family, direction=ApData.dir,
                                                           location=[ApData.hw_loc],
                                                           interface=None)
            else:
                ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                                 traffic={seq: [matches, rx_count1]}, location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclPhy_ingress']
        AclBaseAp._get_tcs_data(ApData)
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir, interface=ApData.intf, mode="unconfig")
    def test_Ipv4CommonACLPhySubIngress(self):
        """
        Ipv4 Common ACL on Ingress PhySub intf

        This test-case verifies 2 level ACL Chaining
        When traffic hits on interface common ACL is verified frist and then interface ACL in chaining fashion.

        Test Procedure:
            - Config 2 diff Ipv4 ACL
            - Attach 1 interface ACL and 1 common ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACL
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None


        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclPhySub_Ingress']

        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        AclBaseAp._get_loc_int(ApData, ApData.intf)
        acl_name = ['ipv4_chain_acl']
        for acl in acl_name:
            ApData.acl_uut.clear_acl_stats(access_list_name=acl, address_family=ApData.addr_family,
                                           direction=ApData.dir, interface=None, location=ApData.hw_loc)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_PhySub', 'peer1_In_UDP_PhySub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        tx_data = {'ipv4_chain_acl': ['peer1_In_UDP_PhySub', '20'],
                   'ipv4_chain_common_acl': ['peer1_In_TCP_PhySub', '50']}
        for aclname in tx_data.keys():
            matches = ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
            seq = tx_data[aclname][1]
            ApData.aclname = aclname
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=seq,
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
            if aclname == 'ipv4_chain_common_acl':
                ApData.acl_uut.verify_common_acl_hit_count(expected_data_obj=verifier_obj,
                                                           access_list_name=ApData.aclname,
                                                           addr_family=ApData.addr_family, direction=ApData.dir,
                                                           location=[ApData.hw_loc],
                                                           interface=None)
            else:
                ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                                 traffic={seq: [matches, rx_count1]}, location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclPhySub_Ingress']
        AclBaseAp._get_tcs_data(ApData)
        intf2 = ApData.UUT1.get_local(ApData.link).name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")

    def test_Ipv4CommonACLBundlePhyIngress(self):
        """
        Ipv4 Common ACL on Ingress Bundle intf


        This test-case verifies 2 level ACL Chaining
        When traffic hits on interface common ACL is verified frist and then interface ACL in chaining fashion.

        Test Procedure:
            - Config 2 diff Ipv4 ACL
            - Attach 1 interface ACL and 1 common ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACL
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None

        """
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclBundlePhy_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf2, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        acl_name = ['ipv4_chain_acl']
        for aclname in acl_name:
            ApData.verify_Bundle_TC(self, acl=aclname, sequance_no=0, TX_frame=0, addr_family=ApData.addr_family,
                                    dir=ApData.dir, location=loc, clear=True, verify=False)

        """
        Verify Traffic
        """
        stream = ['peer2_In_TCP_Bundle', 'peer2_In_UDP_Bundle']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        tx_data = dict()
        seq = 0

        tx_data = {'ipv4_chain_acl': ['peer2_In_UDP_Bundle', '20'],
                   'ipv4_chain_common_acl': ['peer2_In_TCP_Bundle', '50']}
        for aclname in tx_data.keys():
            matches = ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
            ApData.aclname = aclname
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=tx_data[aclname][1],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
            if aclname == 'ipv4_chain_common_acl':
                ApData.acl_uut.verify_common_acl_hit_count(expected_data_obj=verifier_obj,
                                                           access_list_name=ApData.aclname,
                                                           addr_family=ApData.addr_family, direction=ApData.dir,
                                                           location=[ApData.hw_loc],
                                                           interface=None)
            else:
                ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                                 traffic={seq: [matches, rx_count1]}, location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclBundlePhy_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=intf2, mode="unconfig")

    def test_Ipv4CommonACLBundlePhySubIngress(self):
        """
        Ipv4 Common ACL on Ingress Bundle Sub intf

        This test-case verifies 2 level ACL Chaining
        When traffic hits on interface common ACL is verified frist and then interface ACL in chaining fashion.

        Test Procedure:
            - Config 2 diff Ipv4 ACL
            - Attach 1 interface ACL and 1 common ACL to Phy interface on Ingress direction
            - Send traffic
            - Verify hardware hit count on interface

        Configurations:
            - Config ACL
            - Attach to interface

        Verifications:
            - Verify hardware hit count

        Triggers:
            - None


        """

        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclBundlePhySub_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="config")

        loc = []
        ApData.intf1 = ApData.member[0].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf1)
        loc.append(ApData.hw_loc)
        ApData.intf2 = ApData.member[1].interface
        AclBaseAp._get_loc_int(ApData, ApData.intf2)
        loc.append(ApData.hw_loc)
        acl_name = ['ipv4_chain_acl']
        for aclname in acl_name:
            ApData.verify_Bundle_TC(self, acl=aclname, sequance_no=0, TX_frame=0, addr_family=ApData.addr_family,
                                    dir=ApData.dir, location=loc, clear=True, verify=False)

        """
        Verify Traffic
        """
        stream = ['peer1_In_TCP_BunSub', 'peer1_In_UDP_BunSub']
        AclBaseAp.traffic_verifier(ApData, stream_name=stream)

        """
        Verify hardware hit count on interface 
        """
        tx_data = dict()
        seq = 0
        tx_data = {'ipv4_chain_acl': ['peer1_In_UDP_BunSub', '20'],
                   'ipv4_chain_common_acl': ['peer1_In_TCP_BunSub', '50']}
        for aclname in tx_data.keys():
            matches = ApData.stream_stats[tx_data[aclname][0]]['Tx Frames']
            ApData.aclname = aclname
            verifier_obj = []
            verifier_obj.append(
                ApData.acl_uut.HardwareMatches(access_list_name=ApData.aclname, sequence_number=tx_data[aclname][1],
                                               matches=CyDiff.Range(AclBaseAp.tolerance_value(matches, extra=False),
                                                                    AclBaseAp.tolerance_value(matches, extra=True))))
            rx_count1 = ApData.stream_stats[tx_data[aclname][0]]['Rx Frames']
            if aclname == 'ipv4_chain_common_acl':
                ApData.acl_uut.verify_common_acl_hit_count(expected_data_obj=verifier_obj,
                                                           access_list_name=ApData.aclname,
                                                           addr_family=ApData.addr_family, direction=ApData.dir,
                                                           location=[ApData.hw_loc],
                                                           interface=None)
            else:
                ApData.acl_uut.get_acl_hit_count(ApData, expected_data_obj=verifier_obj,
                                                 traffic={seq: [matches, rx_count1]}, location=[ApData.hw_loc])

    def teardown_class(self):
        ApData.test_case = ApData.acl_data['test_args']['apply_intf']['Ipv4CommonAclBundlePhySub_ingress']
        AclBaseAp._get_bun_data(ApData)
        intf2 = ApData.interfaces[ApData.intfl].name
        ApData.intf = intf2 + '.' + ApData.test_case['subint']

        ApData.acl_uut.set_acl_to_interface(access_list_name=ApData.aclname, address_family=ApData.addr_family,
                                            direction=ApData.dir,
                                            interface=ApData.intf, mode="unconfig")


